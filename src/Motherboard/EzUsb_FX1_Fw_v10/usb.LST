C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN usb.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE usb.c OPTIMIZE(9,SIZE) INCDIR(..\..\Common_Ez_Z8) DEFINE(EZ_COMPIL) CODE LI
                    -STINCLUDE SYMBOLS PREPRINT

line level    source

   1          //#pragma NOIV  // Do not generate interrupt vectors
   2           
   3          #include "fx2.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      FX2.h
   3      =1  //   Contents:  EZ-USB FX2/FX2LP/FX1 constants, macros, datatypes, globals, and library
   4      =1  //              function prototypes.
   5      =1  //
   6      =1  // $Archive: /USB/Target/Inc/Fx2.h $
   7      =1  // $Date: 3/23/05 2:30p $
   8      =1  // $Revision: 16 $
   9      =1  //
  10      =1  //   Copyright (c) 2005 Cypress Semiconductor, All rights reserved
  11      =1  //-----------------------------------------------------------------------------
  12      =1  #ifndef FX2_H     //Header sentry
  13      =1  #define FX2_H
  14      =1  
  15      =1  #define INTERNAL_DSCR_ADDR 0x0080   // Relocate Descriptors to 0x80
  16      =1  #define bmSTRETCH 0x07
  17      =1  #define FW_STRETCH_VALUE 0x0      // Set stretch to 0 in frameworks
  18      =1  
  19      =1  //-----------------------------------------------------------------------------
  20      =1  // Constants
  21      =1  //-----------------------------------------------------------------------------
  22      =1  #define   TRUE    1
  23      =1  #define FALSE   0
  24      =1  
  25      =1  #define bmBIT0   0x01
  26      =1  #define bmBIT1   0x02
  27      =1  #define bmBIT2   0x04
  28      =1  #define bmBIT3   0x08
  29      =1  #define bmBIT4   0x10
  30      =1  #define bmBIT5   0x20
  31      =1  #define bmBIT6   0x40
  32      =1  #define bmBIT7   0x80
  33      =1  
  34      =1  #define DEVICE_DSCR      0x01      // Descriptor type: Device
  35      =1  #define CONFIG_DSCR      0x02      // Descriptor type: Configuration
  36      =1  #define STRING_DSCR      0x03      // Descriptor type: String
  37      =1  #define INTRFC_DSCR      0x04      // Descriptor type: Interface
  38      =1  #define ENDPNT_DSCR      0x05      // Descriptor type: End Point
  39      =1  #define DEVQUAL_DSCR     0x06      // Descriptor type: Device Qualifier
  40      =1  #define OTHERSPEED_DSCR  0x07      // Descriptor type: Other Speed Configuration
  41      =1  
  42      =1  #define bmBUSPWR  bmBIT7         // Config. attribute: Bus powered
  43      =1  #define bmSELFPWR bmBIT6         // Config. attribute: Self powered
  44      =1  #define bmRWU     bmBIT5         // Config. attribute: Remote Wakeup
  45      =1  
  46      =1  #define bmEPOUT   bmBIT7
  47      =1  #define bmEPIN    0x00
  48      =1  
  49      =1  #define EP_CONTROL   0x00        // End Point type: Control
  50      =1  #define EP_ISO       0x01        // End Point type: Isochronous
  51      =1  #define EP_BULK      0x02        // End Point type: Bulk
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 2   

  52      =1  #define EP_INT       0x03        // End Point type: Interrupt
  53      =1  
  54      =1  #define SUD_SIZE            8      // Setup data packet size
  55      =1  
  56      =1  //////////////////////////////////////////////////////////////////////////////
  57      =1  //Added for HID
  58      =1  
  59      =1  #define SETUP_MASK                              0x60    //Used to mask off request type
  60      =1  #define SETUP_STANDARD_REQUEST  0               //Standard Request
  61      =1  #define SETUP_CLASS_REQUEST             0x20    //Class Request
  62      =1  #define SETUP_VENDOR_REQUEST    0x40    //Vendor Request
  63      =1  #define SETUP_RESERVED_REQUEST  0x60    //Reserved or illegal request
  64      =1  
  65      =1  //////////////////////////////////////////////////////////////////////////////
  66      =1  
  67      =1  
  68      =1  #define SC_GET_STATUS         0x00   // Setup command: Get Status
  69      =1  #define SC_CLEAR_FEATURE      0x01   // Setup command: Clear Feature
  70      =1  #define SC_RESERVED            0x02   // Setup command: Reserved
  71      =1  #define SC_SET_FEATURE         0x03   // Setup command: Set Feature
  72      =1  #define SC_SET_ADDRESS         0x05   // Setup command: Set Address
  73      =1  #define SC_GET_DESCRIPTOR      0x06   // Setup command: Get Descriptor
  74      =1  #define SC_SET_DESCRIPTOR      0x07   // Setup command: Set Descriptor
  75      =1  #define SC_GET_CONFIGURATION   0x08   // Setup command: Get Configuration
  76      =1  #define SC_SET_CONFIGURATION   0x09   // Setup command: Set Configuration
  77      =1  #define SC_GET_INTERFACE      0x0a   // Setup command: Get Interface
  78      =1  #define SC_SET_INTERFACE      0x0b   // Setup command: Set Interface
  79      =1  #define SC_SYNC_FRAME         0x0c   // Setup command: Sync Frame
  80      =1  #define SC_ANCHOR_LOAD         0xa0   // Setup command: Anchor load
  81      =1     
  82      =1  #define GD_DEVICE          0x01  // Get descriptor: Device
  83      =1  #define GD_CONFIGURATION   0x02  // Get descriptor: Configuration
  84      =1  #define GD_STRING          0x03  // Get descriptor: String
  85      =1  #define GD_INTERFACE       0x04  // Get descriptor: Interface
  86      =1  #define GD_ENDPOINT        0x05  // Get descriptor: Endpoint
  87      =1  #define GD_DEVICE_QUALIFIER 0x06  // Get descriptor: Device Qualifier
  88      =1  #define GD_OTHER_SPEED_CONFIGURATION 0x07  // Get descriptor: Other Configuration
  89      =1  #define GD_INTERFACE_POWER 0x08  // Get descriptor: Interface Power
  90      =1  #define GD_HID              0x21        // Get descriptor: HID
  91      =1  #define GD_REPORT                0x22   // Get descriptor: Report
  92      =1  
  93      =1  #define GS_DEVICE          0x80  // Get Status: Device
  94      =1  #define GS_INTERFACE       0x81  // Get Status: Interface
  95      =1  #define GS_ENDPOINT        0x82  // Get Status: End Point
  96      =1  
  97      =1  #define FT_DEVICE          0x00  // Feature: Device
  98      =1  #define FT_ENDPOINT        0x02  // Feature: End Point
  99      =1  
 100      =1  #define I2C_IDLE              0     // I2C Status: Idle mode
 101      =1  #define I2C_SENDING           1     // I2C Status: I2C is sending data
 102      =1  #define I2C_RECEIVING         2     // I2C Status: I2C is receiving data
 103      =1  #define I2C_PRIME             3     // I2C Status: I2C is receiving the first byte of a string
 104      =1  #define I2C_STOP              5     // I2C Status: I2C waiting for stop completion
 105      =1  #define I2C_BERROR            6     // I2C Status: I2C error; Bit Error
 106      =1  #define I2C_NACK              7     // I2C Status: I2C error; No Acknowledge
 107      =1  #define I2C_OK                8     // I2C positive return code
 108      =1  #define I2C_WAITSTOP          9     // I2C Status: Wait for STOP complete
 109      =1  
 110      =1  /*-----------------------------------------------------------------------------
 111      =1     Macros
 112      =1  -----------------------------------------------------------------------------*/
 113      =1  
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 3   

 114      =1  #define MSB(word)      (BYTE)(((WORD)(word) >> 8) & 0xff)
 115      =1  #define LSB(word)      (BYTE)((WORD)(word) & 0xff)
 116      =1  
 117      =1  #define SWAP_ENDIAN(word)   ((BYTE*)&word)[0] ^= ((BYTE*)&word)[1];\
 118      =1                       ((BYTE*)&word)[1] ^= ((BYTE*)&word)[0];\
 119      =1                       ((BYTE*)&word)[0] ^= ((BYTE*)&word)[1]
 120      =1  
 121      =1  #define EZUSB_IRQ_ENABLE()   EUSB = 1
 122      =1  #define EZUSB_IRQ_DISABLE()   EUSB = 0
 123      =1  #define EZUSB_IRQ_CLEAR()   EXIF &= ~0x10      // IE2_
 124      =1  
 125      =1  #define EZUSB_STALL_EP0()            EP0CS |= bmEPSTALL
 126      =1  
 127      =1  // WRITEDELAY() has been replaced by SYNCDELAY; macro in fx2sdly.h
 128      =1  // ...it is here for backwards compatibility...
 129      =1  
 130      =1  // the WRITEDELAY macro compiles to the time equivalent of 3 NOPs.
 131      =1  // It is used in the frameworks to allow for write recovery time
 132      =1  // requirements of certain registers.  This is only necessary for
 133      =1  // EZ-USB FX parts.  See the EZ-USB FX TRM for
 134      =1  // more information on write recovery time issues.
 135      =1  #define WRITEDELAY() {char writedelaydummy = 0;}
 136      =1  // if this firmware will never run on an EZ-USB FX part replace
 137      =1  // with:
 138      =1  // #define WRITEDELAY()
 139      =1  
 140      =1  // macro to reset and endpoint data toggle
 141      =1  #define EZUSB_RESET_DATA_TOGGLE(ep)     TOGCTL = (((ep & 0x80) >> 3) + (ep & 0x0F));\
 142      =1                                          TOGCTL |= bmRESETTOGGLE
 143      =1  
 144      =1  
 145      =1  #define EZUSB_ENABLE_RSMIRQ()      (EICON |= 0x20)      // Enable Resume Interrupt (EPFI_)
 146      =1  #define EZUSB_DISABLE_RSMIRQ()      (EICON &= ~0x20)   // Disable Resume Interrupt (EPFI_)
 147      =1  #define EZUSB_CLEAR_RSMIRQ()      (EICON &= ~0x10)   // Clear Resume Interrupt Flag (PFI_)
 148      =1  
 149      =1  #define EZUSB_GETI2CSTATUS()      (I2CPckt.status)
 150      =1  #define EZUSB_CLEARI2CSTATUS()      if((I2CPckt.status == I2C_BERROR) || (I2CPckt.status == I2C_NACK))\
 151      =1                                I2CPckt.status = I2C_IDLE;
 152      =1  
 153      =1  #define EZUSB_ENABLEBP()         (BREAKPT |= bmBPEN)
 154      =1  #define EZUSB_DISABLEBP()         (BREAKPT &= ~bmBPEN)
 155      =1  #define EZUSB_CLEARBP()            (BREAKPT |= bmBREAK)
 156      =1  #define EZUSB_BP(addr)            BPADDRH = (BYTE)(((WORD)addr >> 8) & 0xff);\      
 157      =1                                    BPADDRL = (BYTE)addr
 158      =1  
 159      =1  #define EZUSB_EXTWAKEUP()      (((WAKEUPCS & bmWU2) && (WAKEUPCS & bmWU2EN)) ||\
 160      =1                                  ((WAKEUPCS & bmWU) &&  (WAKEUPCS & bmWUEN)))
 161      =1  
 162      =1  #define EZUSB_HIGHSPEED()      (USBCS & bmHSM)
 163      =1  
 164      =1  //-----------------------------------------------------------------------------
 165      =1  // Datatypes
 166      =1  //-----------------------------------------------------------------------------
 167      =1  typedef unsigned char   BYTE;
 168      =1  typedef unsigned short   WORD;
 169      =1  typedef unsigned long   DWORD;
 170      =1  typedef bit            BOOL;
 171      =1  
 172      =1  #define  INT0_VECT   0
 173      =1  #define  TMR0_VECT   1
 174      =1  #define  INT1_VECT   2
 175      =1  #define  TMR1_VECT   3
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 4   

 176      =1  #define  COM0_VECT   4
 177      =1  #define  TMR2_VECT   5
 178      =1  #define  WKUP_VECT   6
 179      =1  #define  COM1_VECT   7
 180      =1  #define  USB_VECT    8
 181      =1  #define  I2C_VECT    9
 182      =1  #define  INT4_VECT   10
 183      =1  #define  INT5_VECT   11
 184      =1  #define  INT6_VECT   12
 185      =1  
 186      =1  
 187      =1  typedef struct
 188      =1  {
 189      =1     BYTE   length;
 190      =1     BYTE   type;
 191      =1  }DSCR;
 192      =1  
 193      =1  typedef struct            // Device Descriptor
 194      =1  {
 195      =1     BYTE   length;         // Descriptor length ( = sizeof(DEVICEDSCR) )
 196      =1     BYTE   type;         // Decriptor type (Device = 1)
 197      =1     BYTE   spec_ver_minor;   // Specification Version (BCD) minor
 198      =1     BYTE   spec_ver_major;   // Specification Version (BCD) major
 199      =1     BYTE   dev_class;      // Device class
 200      =1     BYTE   sub_class;      // Device sub-class
 201      =1     BYTE   protocol;      // Device sub-sub-class
 202      =1     BYTE   max_packet;      // Maximum packet size
 203      =1     WORD   vendor_id;      // Vendor ID
 204      =1     WORD   product_id;      // Product ID
 205      =1     WORD   version_id;      // Product version ID
 206      =1     BYTE   mfg_str;      // Manufacturer string index
 207      =1     BYTE   prod_str;      // Product string index
 208      =1     BYTE   serialnum_str;   // Serial number string index
 209      =1     BYTE   configs;      // Number of configurations
 210      =1  }DEVICEDSCR;
 211      =1  
 212      =1  typedef struct            // Device Qualifier Descriptor
 213      =1  {
 214      =1     BYTE   length;         // Descriptor length ( = sizeof(DEVICEQUALDSCR) )
 215      =1     BYTE   type;         // Decriptor type (Device Qualifier = 6)
 216      =1     BYTE   spec_ver_minor;   // Specification Version (BCD) minor
 217      =1     BYTE   spec_ver_major;   // Specification Version (BCD) major
 218      =1     BYTE   dev_class;      // Device class
 219      =1     BYTE   sub_class;      // Device sub-class
 220      =1     BYTE   protocol;      // Device sub-sub-class
 221      =1     BYTE   max_packet;      // Maximum packet size
 222      =1     BYTE   configs;      // Number of configurations
 223      =1     BYTE  reserved0;
 224      =1  }DEVICEQUALDSCR;
 225      =1  
 226      =1  typedef struct
 227      =1  {
 228      =1     BYTE   length;         // Configuration length ( = sizeof(CONFIGDSCR) )
 229      =1     BYTE   type;         // Descriptor type (Configuration = 2)
 230      =1     WORD   config_len;      // Configuration + End Points length
 231      =1     BYTE   interfaces;      // Number of interfaces
 232      =1     BYTE   index;         // Configuration number
 233      =1     BYTE   config_str;      // Configuration string
 234      =1     BYTE   attrib;         // Attributes (b7 - buspwr, b6 - selfpwr, b5 - rwu
 235      =1     BYTE   power;         // Power requirement (div 2 ma)
 236      =1  }CONFIGDSCR;
 237      =1  
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 5   

 238      =1  typedef struct
 239      =1  {
 240      =1     BYTE   length;         // Interface descriptor length ( - sizeof(INTRFCDSCR) )
 241      =1     BYTE   type;         // Descriptor type (Interface = 4)
 242      =1     BYTE   index;         // Zero-based index of this interface
 243      =1     BYTE   alt_setting;   // Alternate setting
 244      =1     BYTE   ep_cnt;         // Number of end points 
 245      =1     BYTE   class;         // Interface class
 246      =1     BYTE   sub_class;      // Interface sub class
 247      =1     BYTE   protocol;      // Interface sub sub class
 248      =1     BYTE   interface_str;   // Interface descriptor string index
 249      =1  }INTRFCDSCR;
 250      =1  
 251      =1  typedef struct
 252      =1  {
 253      =1     BYTE   length;         // End point descriptor length ( = sizeof(ENDPNTDSCR) )
 254      =1     BYTE   type;         // Descriptor type (End point = 5)
 255      =1     BYTE   addr;         // End point address
 256      =1     BYTE   ep_type;      // End point type
 257      =1     BYTE   mp_L;         // Maximum packet size
 258      =1     BYTE   mp_H;
 259      =1     BYTE   interval;      // Interrupt polling interval
 260      =1  }ENDPNTDSCR;
 261      =1  
 262      =1  typedef struct
 263      =1  {
 264      =1     BYTE   length;         // String descriptor length
 265      =1     BYTE   type;         // Descriptor type
 266      =1  }STRINGDSCR;
 267      =1  
 268      =1  typedef struct
 269      =1  {
 270      =1     BYTE   cntrl;         // End point control register
 271      =1     BYTE   bytes;         // End point buffer byte count
 272      =1  }EPIOC;
 273      =1  
 274      =1  typedef struct 
 275      =1  {
 276      =1     BYTE   length;
 277      =1     BYTE   *dat;
 278      =1     BYTE   count;
 279      =1     BYTE   status;
 280      =1  }I2CPCKT;
 281      =1  
 282      =1  //-----------------------------------------------------------------------------
 283      =1  // Globals
 284      =1  //-----------------------------------------------------------------------------
 285      =1  extern code BYTE   USB_AutoVector;
 286      =1  
 287      =1  extern WORD   pDeviceDscr;
 288      =1  extern WORD   pDeviceQualDscr;
 289      =1  extern WORD       pHighSpeedConfigDscr;
 290      =1  extern WORD       pFullSpeedConfigDscr; 
 291      =1  extern WORD   pConfigDscr;
 292      =1  extern WORD   pOtherConfigDscr;
 293      =1  extern WORD   pStringDscr;
 294      =1  
 295      =1  extern code DEVICEDSCR        DeviceDscr;
 296      =1  extern code DEVICEQUALDSCR    DeviceQualDscr;
 297      =1  extern code CONFIGDSCR        HighSpeedConfigDscr;
 298      =1  extern code CONFIGDSCR        FullSpeedConfigDscr;
 299      =1  extern code STRINGDSCR        StringDscr;
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 6   

 300      =1  extern code DSCR              UserDscr;
 301      =1  
 302      =1  extern I2CPCKT   I2CPckt;
 303      =1  
 304      =1  //-----------------------------------------------------------------------------
 305      =1  // Function Prototypes
 306      =1  //-----------------------------------------------------------------------------
 307      =1  
 308      =1  extern void EZUSB_Renum(void);
 309      =1  extern void EZUSB_Discon(BOOL renum);
 310      =1  
 311      =1  extern void EZUSB_Susp(void);
 312      =1  extern void EZUSB_Resume(void);
 313      =1  
 314      =1  extern void EZUSB_Delay1ms(void);
 315      =1  extern void EZUSB_Delay(WORD ms);
 316      =1  
 317      =1  extern CONFIGDSCR xdata*   EZUSB_GetConfigDscr(BYTE ConfigIdx);
 318      =1  extern INTRFCDSCR xdata*   EZUSB_GetIntrfcDscr(BYTE ConfigIdx, BYTE IntrfcIdx, BYTE AltSetting);
 319      =1  extern STRINGDSCR xdata*   EZUSB_GetStringDscr(BYTE StrIdx);
 320      =1  extern DSCR xdata*      EZUSB_GetDscr(BYTE index, DSCR* dscr, BYTE type);
 321      =1  
 322      =1  extern void EZUSB_InitI2C(void);
 323      =1  extern BOOL EZUSB_WriteI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 324      =1  extern BOOL EZUSB_ReadI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 325      =1  extern BOOL EZUSB_WriteI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 326      =1  extern BOOL EZUSB_ReadI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 327      =1  extern void EZUSB_WaitForEEPROMWrite(BYTE addr);
 328      =1  
 329      =1  extern void modify_endpoint_stall(BYTE epid, BYTE stall);
 330      =1  
 331      =1  #endif   // FX2_H
   4          #include "fx2regs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      FX2regs.h
   3      =1  //   Contents:   EZ-USB FX2/FX2LP/FX1 register declarations and bit mask definitions.
   4      =1  //
   5      =1  // $Archive: /USB/Target/Inc/fx2regs.h $
   6      =1  // $Date: 4/13/05 4:29p $
   7      =1  // $Revision: 42 $
   8      =1  //
   9      =1  //
  10      =1  //   Copyright (c) 2005 Cypress Semiconductor, All rights reserved
  11      =1  //-----------------------------------------------------------------------------
  12      =1  
  13      =1  #ifndef FX2REGS_H   /* Header Sentry */
  14      =1  #define FX2REGS_H
  15      =1  
  16      =1  //-----------------------------------------------------------------------------
  17      =1  // FX2/FX2LP/FX1 Related Register Assignments
  18      =1  //-----------------------------------------------------------------------------
  19      =1  
  20      =1  // The Ez-USB FX2/FX2LP/FX1 registers are defined here. We use fx2regs.h for register 
  21      =1  // address allocation by using "#define ALLOCATE_EXTERN". 
  22      =1  // When using "#define ALLOCATE_EXTERN", you get (for instance): 
  23      =1  // xdata volatile BYTE OUT7BUF[64]   _at_   0x7B40;
  24      =1  // Such lines are created from FX2.h by using the preprocessor. 
  25      =1  // Incidently, these lines will not generate any space in the resulting hex 
  26      =1  // file; they just bind the symbols to the addresses for compilation. 
  27      =1  // You just need to put "#define ALLOCATE_EXTERN" in your main program file; 
  28      =1  // i.e. fw.c or a stand-alone C source file. 
  29      =1  // Without "#define ALLOCATE_EXTERN", you just get the external reference: 
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 7   

  30      =1  // extern xdata volatile BYTE OUT7BUF[64]   ;//   0x7B40;
  31      =1  // This uses the concatenation operator "##" to insert a comment "//" 
  32      =1  // to cut off the end of the line, "_at_   0x7B40;", which is not wanted.
  33      =1  
  34      =1  #ifdef ALLOCATE_EXTERN
           =1 #define EXTERN
           =1 #define _AT_ _at_
           =1 #else
  38      =1  #define EXTERN extern
  39      =1  #define _AT_ ;/ ## /
  40      =1  #endif
  41      =1  
  42      =1  EXTERN xdata volatile BYTE GPIF_WAVE_DATA    _AT_ 0xE400;
  43      =1  EXTERN xdata volatile BYTE RES_WAVEDATA_END  _AT_ 0xE480;
  44      =1  
  45      =1  // General Configuration
  46      =1  
  47      =1  EXTERN xdata volatile BYTE CPUCS             _AT_ 0xE600;  // Control & Status
  48      =1  EXTERN xdata volatile BYTE IFCONFIG          _AT_ 0xE601;  // Interface Configuration
  49      =1  EXTERN xdata volatile BYTE PINFLAGSAB        _AT_ 0xE602;  // FIFO FLAGA and FLAGB Assignments
  50      =1  EXTERN xdata volatile BYTE PINFLAGSCD        _AT_ 0xE603;  // FIFO FLAGC and FLAGD Assignments
  51      =1  EXTERN xdata volatile BYTE FIFORESET         _AT_ 0xE604;  // Restore FIFOS to default state
  52      =1  EXTERN xdata volatile BYTE BREAKPT           _AT_ 0xE605;  // Breakpoint
  53      =1  EXTERN xdata volatile BYTE BPADDRH           _AT_ 0xE606;  // Breakpoint Address H
  54      =1  EXTERN xdata volatile BYTE BPADDRL           _AT_ 0xE607;  // Breakpoint Address L
  55      =1  EXTERN xdata volatile BYTE UART230           _AT_ 0xE608;  // 230 Kbaud clock for T0,T1,T2
  56      =1  EXTERN xdata volatile BYTE FIFOPINPOLAR      _AT_ 0xE609;  // FIFO polarities
  57      =1  EXTERN xdata volatile BYTE REVID             _AT_ 0xE60A;  // Chip Revision
  58      =1  EXTERN xdata volatile BYTE REVCTL            _AT_ 0xE60B;  // Chip Revision Control
  59      =1  
  60      =1  // Endpoint Configuration
  61      =1  
  62      =1  EXTERN xdata volatile BYTE EP1OUTCFG         _AT_ 0xE610;  // Endpoint 1-OUT Configuration
  63      =1  EXTERN xdata volatile BYTE EP1INCFG          _AT_ 0xE611;  // Endpoint 1-IN Configuration
  64      =1  EXTERN xdata volatile BYTE EP2CFG            _AT_ 0xE612;  // Endpoint 2 Configuration
  65      =1  EXTERN xdata volatile BYTE EP4CFG            _AT_ 0xE613;  // Endpoint 4 Configuration
  66      =1  EXTERN xdata volatile BYTE EP6CFG            _AT_ 0xE614;  // Endpoint 6 Configuration
  67      =1  EXTERN xdata volatile BYTE EP8CFG            _AT_ 0xE615;  // Endpoint 8 Configuration
  68      =1  EXTERN xdata volatile BYTE EP2FIFOCFG        _AT_ 0xE618;  // Endpoint 2 FIFO configuration
  69      =1  EXTERN xdata volatile BYTE EP4FIFOCFG        _AT_ 0xE619;  // Endpoint 4 FIFO configuration
  70      =1  EXTERN xdata volatile BYTE EP6FIFOCFG        _AT_ 0xE61A;  // Endpoint 6 FIFO configuration
  71      =1  EXTERN xdata volatile BYTE EP8FIFOCFG        _AT_ 0xE61B;  // Endpoint 8 FIFO configuration
  72      =1  EXTERN xdata volatile BYTE EP2AUTOINLENH     _AT_ 0xE620;  // Endpoint 2 Packet Length H (IN only)
  73      =1  EXTERN xdata volatile BYTE EP2AUTOINLENL     _AT_ 0xE621;  // Endpoint 2 Packet Length L (IN only)
  74      =1  EXTERN xdata volatile BYTE EP4AUTOINLENH     _AT_ 0xE622;  // Endpoint 4 Packet Length H (IN only)
  75      =1  EXTERN xdata volatile BYTE EP4AUTOINLENL     _AT_ 0xE623;  // Endpoint 4 Packet Length L (IN only)
  76      =1  EXTERN xdata volatile BYTE EP6AUTOINLENH     _AT_ 0xE624;  // Endpoint 6 Packet Length H (IN only)
  77      =1  EXTERN xdata volatile BYTE EP6AUTOINLENL     _AT_ 0xE625;  // Endpoint 6 Packet Length L (IN only)
  78      =1  EXTERN xdata volatile BYTE EP8AUTOINLENH     _AT_ 0xE626;  // Endpoint 8 Packet Length H (IN only)
  79      =1  EXTERN xdata volatile BYTE EP8AUTOINLENL     _AT_ 0xE627;  // Endpoint 8 Packet Length L (IN only)
  80      =1  EXTERN xdata volatile BYTE EP2FIFOPFH        _AT_ 0xE630;  // EP2 Programmable Flag trigger H
  81      =1  EXTERN xdata volatile BYTE EP2FIFOPFL        _AT_ 0xE631;  // EP2 Programmable Flag trigger L
  82      =1  EXTERN xdata volatile BYTE EP4FIFOPFH        _AT_ 0xE632;  // EP4 Programmable Flag trigger H
  83      =1  EXTERN xdata volatile BYTE EP4FIFOPFL        _AT_ 0xE633;  // EP4 Programmable Flag trigger L
  84      =1  EXTERN xdata volatile BYTE EP6FIFOPFH        _AT_ 0xE634;  // EP6 Programmable Flag trigger H
  85      =1  EXTERN xdata volatile BYTE EP6FIFOPFL        _AT_ 0xE635;  // EP6 Programmable Flag trigger L
  86      =1  EXTERN xdata volatile BYTE EP8FIFOPFH        _AT_ 0xE636;  // EP8 Programmable Flag trigger H
  87      =1  EXTERN xdata volatile BYTE EP8FIFOPFL        _AT_ 0xE637;  // EP8 Programmable Flag trigger L
  88      =1  EXTERN xdata volatile BYTE EP2ISOINPKTS      _AT_ 0xE640;  // EP2 (if ISO) IN Packets per frame (1-3)
  89      =1  EXTERN xdata volatile BYTE EP4ISOINPKTS      _AT_ 0xE641;  // EP4 (if ISO) IN Packets per frame (1-3)
  90      =1  EXTERN xdata volatile BYTE EP6ISOINPKTS      _AT_ 0xE642;  // EP6 (if ISO) IN Packets per frame (1-3)
  91      =1  EXTERN xdata volatile BYTE EP8ISOINPKTS      _AT_ 0xE643;  // EP8 (if ISO) IN Packets per frame (1-3)
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 8   

  92      =1  EXTERN xdata volatile BYTE INPKTEND          _AT_ 0xE648;  // Force IN Packet End
  93      =1  EXTERN xdata volatile BYTE OUTPKTEND         _AT_ 0xE649;  // Force OUT Packet End
  94      =1  
  95      =1  // Interrupts
  96      =1  
  97      =1  EXTERN xdata volatile BYTE EP2FIFOIE         _AT_ 0xE650;  // Endpoint 2 Flag Interrupt Enable
  98      =1  EXTERN xdata volatile BYTE EP2FIFOIRQ        _AT_ 0xE651;  // Endpoint 2 Flag Interrupt Request
  99      =1  EXTERN xdata volatile BYTE EP4FIFOIE         _AT_ 0xE652;  // Endpoint 4 Flag Interrupt Enable
 100      =1  EXTERN xdata volatile BYTE EP4FIFOIRQ        _AT_ 0xE653;  // Endpoint 4 Flag Interrupt Request
 101      =1  EXTERN xdata volatile BYTE EP6FIFOIE         _AT_ 0xE654;  // Endpoint 6 Flag Interrupt Enable
 102      =1  EXTERN xdata volatile BYTE EP6FIFOIRQ        _AT_ 0xE655;  // Endpoint 6 Flag Interrupt Request
 103      =1  EXTERN xdata volatile BYTE EP8FIFOIE         _AT_ 0xE656;  // Endpoint 8 Flag Interrupt Enable
 104      =1  EXTERN xdata volatile BYTE EP8FIFOIRQ        _AT_ 0xE657;  // Endpoint 8 Flag Interrupt Request
 105      =1  EXTERN xdata volatile BYTE IBNIE             _AT_ 0xE658;  // IN-BULK-NAK Interrupt Enable
 106      =1  EXTERN xdata volatile BYTE IBNIRQ            _AT_ 0xE659;  // IN-BULK-NAK interrupt Request
 107      =1  EXTERN xdata volatile BYTE NAKIE             _AT_ 0xE65A;  // Endpoint Ping NAK interrupt Enable
 108      =1  EXTERN xdata volatile BYTE NAKIRQ            _AT_ 0xE65B;  // Endpoint Ping NAK interrupt Request
 109      =1  EXTERN xdata volatile BYTE USBIE             _AT_ 0xE65C;  // USB Int Enables
 110      =1  EXTERN xdata volatile BYTE USBIRQ            _AT_ 0xE65D;  // USB Interrupt Requests
 111      =1  EXTERN xdata volatile BYTE EPIE              _AT_ 0xE65E;  // Endpoint Interrupt Enables
 112      =1  EXTERN xdata volatile BYTE EPIRQ             _AT_ 0xE65F;  // Endpoint Interrupt Requests
 113      =1  EXTERN xdata volatile BYTE GPIFIE            _AT_ 0xE660;  // GPIF Interrupt Enable
 114      =1  EXTERN xdata volatile BYTE GPIFIRQ           _AT_ 0xE661;  // GPIF Interrupt Request
 115      =1  EXTERN xdata volatile BYTE USBERRIE          _AT_ 0xE662;  // USB Error Interrupt Enables
 116      =1  EXTERN xdata volatile BYTE USBERRIRQ         _AT_ 0xE663;  // USB Error Interrupt Requests
 117      =1  EXTERN xdata volatile BYTE ERRCNTLIM         _AT_ 0xE664;  // USB Error counter and limit
 118      =1  EXTERN xdata volatile BYTE CLRERRCNT         _AT_ 0xE665;  // Clear Error Counter EC[3..0]
 119      =1  EXTERN xdata volatile BYTE INT2IVEC          _AT_ 0xE666;  // Interupt 2 (USB) Autovector
 120      =1  EXTERN xdata volatile BYTE INT4IVEC          _AT_ 0xE667;  // Interupt 4 (FIFOS & GPIF) Autovector
 121      =1  EXTERN xdata volatile BYTE INTSETUP          _AT_ 0xE668;  // Interrupt 2&4 Setup
 122      =1  
 123      =1  // Input/Output
 124      =1  
 125      =1  EXTERN xdata volatile BYTE PORTACFG          _AT_ 0xE670;  // I/O PORTA Alternate Configuration
 126      =1  EXTERN xdata volatile BYTE PORTCCFG          _AT_ 0xE671;  // I/O PORTC Alternate Configuration
 127      =1  EXTERN xdata volatile BYTE PORTECFG          _AT_ 0xE672;  // I/O PORTE Alternate Configuration
 128      =1  EXTERN xdata volatile BYTE I2CS              _AT_ 0xE678;  // Control & Status
 129      =1  EXTERN xdata volatile BYTE I2DAT             _AT_ 0xE679;  // Data
 130      =1  EXTERN xdata volatile BYTE I2CTL             _AT_ 0xE67A;  // I2C Control
 131      =1  EXTERN xdata volatile BYTE XAUTODAT1         _AT_ 0xE67B;  // Autoptr1 MOVX access
 132      =1  EXTERN xdata volatile BYTE XAUTODAT2         _AT_ 0xE67C;  // Autoptr2 MOVX access
 133      =1  
 134      =1  #define EXTAUTODAT1 XAUTODAT1
 135      =1  #define EXTAUTODAT2 XAUTODAT2
 136      =1  
 137      =1  // USB Control
 138      =1  
 139      =1  EXTERN xdata volatile BYTE USBCS             _AT_ 0xE680;  // USB Control & Status
 140      =1  EXTERN xdata volatile BYTE SUSPEND           _AT_ 0xE681;  // Put chip into suspend
 141      =1  EXTERN xdata volatile BYTE WAKEUPCS          _AT_ 0xE682;  // Wakeup source and polarity
 142      =1  EXTERN xdata volatile BYTE TOGCTL            _AT_ 0xE683;  // Toggle Control
 143      =1  EXTERN xdata volatile BYTE USBFRAMEH         _AT_ 0xE684;  // USB Frame count H
 144      =1  EXTERN xdata volatile BYTE USBFRAMEL         _AT_ 0xE685;  // USB Frame count L
 145      =1  EXTERN xdata volatile BYTE MICROFRAME        _AT_ 0xE686;  // Microframe count, 0-7
 146      =1  EXTERN xdata volatile BYTE FNADDR            _AT_ 0xE687;  // USB Function address
 147      =1  
 148      =1  // Endpoints
 149      =1  
 150      =1  EXTERN xdata volatile BYTE EP0BCH            _AT_ 0xE68A;  // Endpoint 0 Byte Count H
 151      =1  EXTERN xdata volatile BYTE EP0BCL            _AT_ 0xE68B;  // Endpoint 0 Byte Count L
 152      =1  EXTERN xdata volatile BYTE EP1OUTBC          _AT_ 0xE68D;  // Endpoint 1 OUT Byte Count
 153      =1  EXTERN xdata volatile BYTE EP1INBC           _AT_ 0xE68F;  // Endpoint 1 IN Byte Count
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 9   

 154      =1  EXTERN xdata volatile BYTE EP2BCH            _AT_ 0xE690;  // Endpoint 2 Byte Count H
 155      =1  EXTERN xdata volatile BYTE EP2BCL            _AT_ 0xE691;  // Endpoint 2 Byte Count L
 156      =1  EXTERN xdata volatile BYTE EP4BCH            _AT_ 0xE694;  // Endpoint 4 Byte Count H
 157      =1  EXTERN xdata volatile BYTE EP4BCL            _AT_ 0xE695;  // Endpoint 4 Byte Count L
 158      =1  EXTERN xdata volatile BYTE EP6BCH            _AT_ 0xE698;  // Endpoint 6 Byte Count H
 159      =1  EXTERN xdata volatile BYTE EP6BCL            _AT_ 0xE699;  // Endpoint 6 Byte Count L
 160      =1  EXTERN xdata volatile BYTE EP8BCH            _AT_ 0xE69C;  // Endpoint 8 Byte Count H
 161      =1  EXTERN xdata volatile BYTE EP8BCL            _AT_ 0xE69D;  // Endpoint 8 Byte Count L
 162      =1  EXTERN xdata volatile BYTE EP0CS             _AT_ 0xE6A0;  // Endpoint  Control and Status
 163      =1  EXTERN xdata volatile BYTE EP1OUTCS          _AT_ 0xE6A1;  // Endpoint 1 OUT Control and Status
 164      =1  EXTERN xdata volatile BYTE EP1INCS           _AT_ 0xE6A2;  // Endpoint 1 IN Control and Status
 165      =1  EXTERN xdata volatile BYTE EP2CS             _AT_ 0xE6A3;  // Endpoint 2 Control and Status
 166      =1  EXTERN xdata volatile BYTE EP4CS             _AT_ 0xE6A4;  // Endpoint 4 Control and Status
 167      =1  EXTERN xdata volatile BYTE EP6CS             _AT_ 0xE6A5;  // Endpoint 6 Control and Status
 168      =1  EXTERN xdata volatile BYTE EP8CS             _AT_ 0xE6A6;  // Endpoint 8 Control and Status
 169      =1  EXTERN xdata volatile BYTE EP2FIFOFLGS       _AT_ 0xE6A7;  // Endpoint 2 Flags
 170      =1  EXTERN xdata volatile BYTE EP4FIFOFLGS       _AT_ 0xE6A8;  // Endpoint 4 Flags
 171      =1  EXTERN xdata volatile BYTE EP6FIFOFLGS       _AT_ 0xE6A9;  // Endpoint 6 Flags
 172      =1  EXTERN xdata volatile BYTE EP8FIFOFLGS       _AT_ 0xE6AA;  // Endpoint 8 Flags
 173      =1  EXTERN xdata volatile BYTE EP2FIFOBCH        _AT_ 0xE6AB;  // EP2 FIFO total byte count H
 174      =1  EXTERN xdata volatile BYTE EP2FIFOBCL        _AT_ 0xE6AC;  // EP2 FIFO total byte count L
 175      =1  EXTERN xdata volatile BYTE EP4FIFOBCH        _AT_ 0xE6AD;  // EP4 FIFO total byte count H
 176      =1  EXTERN xdata volatile BYTE EP4FIFOBCL        _AT_ 0xE6AE;  // EP4 FIFO total byte count L
 177      =1  EXTERN xdata volatile BYTE EP6FIFOBCH        _AT_ 0xE6AF;  // EP6 FIFO total byte count H
 178      =1  EXTERN xdata volatile BYTE EP6FIFOBCL        _AT_ 0xE6B0;  // EP6 FIFO total byte count L
 179      =1  EXTERN xdata volatile BYTE EP8FIFOBCH        _AT_ 0xE6B1;  // EP8 FIFO total byte count H
 180      =1  EXTERN xdata volatile BYTE EP8FIFOBCL        _AT_ 0xE6B2;  // EP8 FIFO total byte count L
 181      =1  EXTERN xdata volatile BYTE SUDPTRH           _AT_ 0xE6B3;  // Setup Data Pointer high address byte
 182      =1  EXTERN xdata volatile BYTE SUDPTRL           _AT_ 0xE6B4;  // Setup Data Pointer low address byte
 183      =1  EXTERN xdata volatile BYTE SUDPTRCTL         _AT_ 0xE6B5;  // Setup Data Pointer Auto Mode
 184      =1  EXTERN xdata volatile BYTE SETUPDAT[8]       _AT_ 0xE6B8;  // 8 bytes of SETUP data
 185      =1  
 186      =1  // GPIF
 187      =1  
 188      =1  EXTERN xdata volatile BYTE GPIFWFSELECT      _AT_ 0xE6C0;  // Waveform Selector
 189      =1  EXTERN xdata volatile BYTE GPIFIDLECS        _AT_ 0xE6C1;  // GPIF Done, GPIF IDLE drive mode
 190      =1  EXTERN xdata volatile BYTE GPIFIDLECTL       _AT_ 0xE6C2;  // Inactive Bus, CTL states
 191      =1  EXTERN xdata volatile BYTE GPIFCTLCFG        _AT_ 0xE6C3;  // CTL OUT pin drive
 192      =1  EXTERN xdata volatile BYTE GPIFADRH          _AT_ 0xE6C4;  // GPIF Address H
 193      =1  EXTERN xdata volatile BYTE GPIFADRL          _AT_ 0xE6C5;  // GPIF Address L
 194      =1  
 195      =1  EXTERN xdata volatile BYTE GPIFTCB3          _AT_ 0xE6CE;  // GPIF Transaction Count Byte 3
 196      =1  EXTERN xdata volatile BYTE GPIFTCB2          _AT_ 0xE6CF;  // GPIF Transaction Count Byte 2
 197      =1  EXTERN xdata volatile BYTE GPIFTCB1          _AT_ 0xE6D0;  // GPIF Transaction Count Byte 1
 198      =1  EXTERN xdata volatile BYTE GPIFTCB0          _AT_ 0xE6D1;  // GPIF Transaction Count Byte 0
 199      =1  
 200      =1  #define EP2GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 201      =1  #define EP2GPIFTCL GPIFTCB0   // 
 202      =1  #define EP4GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 203      =1  #define EP4GPIFTCL GPIFTCB0   // 
 204      =1  #define EP6GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 205      =1  #define EP6GPIFTCL GPIFTCB0   // 
 206      =1  #define EP8GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 207      =1  #define EP8GPIFTCL GPIFTCB0   // 
 208      =1  
 209      =1  EXTERN xdata volatile BYTE EP2GPIFFLGSEL     _AT_ 0xE6D2;  // EP2 GPIF Flag select
 210      =1  EXTERN xdata volatile BYTE EP2GPIFPFSTOP     _AT_ 0xE6D3;  // Stop GPIF EP2 transaction on prog. flag
 211      =1  EXTERN xdata volatile BYTE EP2GPIFTRIG       _AT_ 0xE6D4;  // EP2 FIFO Trigger
 212      =1  EXTERN xdata volatile BYTE EP4GPIFFLGSEL     _AT_ 0xE6DA;  // EP4 GPIF Flag select
 213      =1  EXTERN xdata volatile BYTE EP4GPIFPFSTOP     _AT_ 0xE6DB;  // Stop GPIF EP4 transaction on prog. flag
 214      =1  EXTERN xdata volatile BYTE EP4GPIFTRIG       _AT_ 0xE6DC;  // EP4 FIFO Trigger
 215      =1  EXTERN xdata volatile BYTE EP6GPIFFLGSEL     _AT_ 0xE6E2;  // EP6 GPIF Flag select
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 10  

 216      =1  EXTERN xdata volatile BYTE EP6GPIFPFSTOP     _AT_ 0xE6E3;  // Stop GPIF EP6 transaction on prog. flag
 217      =1  EXTERN xdata volatile BYTE EP6GPIFTRIG       _AT_ 0xE6E4;  // EP6 FIFO Trigger
 218      =1  EXTERN xdata volatile BYTE EP8GPIFFLGSEL     _AT_ 0xE6EA;  // EP8 GPIF Flag select
 219      =1  EXTERN xdata volatile BYTE EP8GPIFPFSTOP     _AT_ 0xE6EB;  // Stop GPIF EP8 transaction on prog. flag
 220      =1  EXTERN xdata volatile BYTE EP8GPIFTRIG       _AT_ 0xE6EC;  // EP8 FIFO Trigger
 221      =1  EXTERN xdata volatile BYTE XGPIFSGLDATH      _AT_ 0xE6F0;  // GPIF Data H (16-bit mode only)
 222      =1  EXTERN xdata volatile BYTE XGPIFSGLDATLX     _AT_ 0xE6F1;  // Read/Write GPIF Data L & trigger transac
 223      =1  EXTERN xdata volatile BYTE XGPIFSGLDATLNOX   _AT_ 0xE6F2;  // Read GPIF Data L, no transac trigger
 224      =1  EXTERN xdata volatile BYTE GPIFREADYCFG      _AT_ 0xE6F3;  // Internal RDY,Sync/Async, RDY5CFG
 225      =1  EXTERN xdata volatile BYTE GPIFREADYSTAT     _AT_ 0xE6F4;  // RDY pin states
 226      =1  EXTERN xdata volatile BYTE GPIFABORT         _AT_ 0xE6F5;  // Abort GPIF cycles
 227      =1  
 228      =1  // UDMA
 229      =1  
 230      =1  EXTERN xdata volatile BYTE FLOWSTATE         _AT_  0xE6C6; //Defines GPIF flow state
 231      =1  EXTERN xdata volatile BYTE FLOWLOGIC         _AT_  0xE6C7; //Defines flow/hold decision criteria
 232      =1  EXTERN xdata volatile BYTE FLOWEQ0CTL        _AT_  0xE6C8; //CTL states during active flow state
 233      =1  EXTERN xdata volatile BYTE FLOWEQ1CTL        _AT_  0xE6C9; //CTL states during hold flow state
 234      =1  EXTERN xdata volatile BYTE FLOWHOLDOFF       _AT_  0xE6CA;
 235      =1  EXTERN xdata volatile BYTE FLOWSTB           _AT_  0xE6CB; //CTL/RDY Signal to use as master data strobe 
 236      =1  EXTERN xdata volatile BYTE FLOWSTBEDGE       _AT_  0xE6CC; //Defines active master strobe edge
 237      =1  EXTERN xdata volatile BYTE FLOWSTBHPERIOD    _AT_  0xE6CD; //Half Period of output master strobe
 238      =1  EXTERN xdata volatile BYTE GPIFHOLDAMOUNT    _AT_  0xE60C; //Data delay shift 
 239      =1  EXTERN xdata volatile BYTE UDMACRCH          _AT_  0xE67D; //CRC Upper byte
 240      =1  EXTERN xdata volatile BYTE UDMACRCL          _AT_  0xE67E; //CRC Lower byte
 241      =1  EXTERN xdata volatile BYTE UDMACRCQUAL       _AT_  0xE67F; //UDMA In only, host terminated use only
 242      =1  
 243      =1  
 244      =1  // Debug/Test
 245      =1  // The following registers are for Cypress's internal testing purposes only.
 246      =1  // These registers are not documented in the datasheet or the Technical Reference
 247      =1  // Manual as they were not designed for end user application usage 
 248      =1  EXTERN xdata volatile BYTE DBUG              _AT_ 0xE6F8;  // Debug
 249      =1  EXTERN xdata volatile BYTE TESTCFG           _AT_ 0xE6F9;  // Test configuration
 250      =1  EXTERN xdata volatile BYTE USBTEST           _AT_ 0xE6FA;  // USB Test Modes
 251      =1  EXTERN xdata volatile BYTE CT1               _AT_ 0xE6FB;  // Chirp Test--Override
 252      =1  EXTERN xdata volatile BYTE CT2               _AT_ 0xE6FC;  // Chirp Test--FSM
 253      =1  EXTERN xdata volatile BYTE CT3               _AT_ 0xE6FD;  // Chirp Test--Control Signals
 254      =1  EXTERN xdata volatile BYTE CT4               _AT_ 0xE6FE;  // Chirp Test--Inputs
 255      =1  
 256      =1  // Endpoint Buffers
 257      =1  
 258      =1  EXTERN xdata volatile BYTE EP0BUF[64]        _AT_ 0xE740;  // EP0 IN-OUT buffer
 259      =1  EXTERN xdata volatile BYTE EP1OUTBUF[64]     _AT_ 0xE780;  // EP1-OUT buffer
 260      =1  EXTERN xdata volatile BYTE EP1INBUF[64]      _AT_ 0xE7C0;  // EP1-IN buffer
 261      =1  EXTERN xdata volatile BYTE EP2FIFOBUF[1024]  _AT_ 0xF000;  // 512/1024-byte EP2 buffer (IN or OUT)
 262      =1  EXTERN xdata volatile BYTE EP4FIFOBUF[1024]  _AT_ 0xF400;  // 512 byte EP4 buffer (IN or OUT)
 263      =1  EXTERN xdata volatile BYTE EP6FIFOBUF[1024]  _AT_ 0xF800;  // 512/1024-byte EP6 buffer (IN or OUT)
 264      =1  EXTERN xdata volatile BYTE EP8FIFOBUF[1024]  _AT_ 0xFC00;  // 512 byte EP8 buffer (IN or OUT)
 265      =1  
 266      =1  // Error Correction Code (ECC) Registers (FX2LP/FX1 only)
 267      =1  
 268      =1  EXTERN xdata volatile BYTE ECCCFG            _AT_ 0xE628;  // ECC Configuration
 269      =1  EXTERN xdata volatile BYTE ECCRESET          _AT_ 0xE629;  // ECC Reset
 270      =1  EXTERN xdata volatile BYTE ECC1B0            _AT_ 0xE62A;  // ECC1 Byte 0
 271      =1  EXTERN xdata volatile BYTE ECC1B1            _AT_ 0xE62B;  // ECC1 Byte 1
 272      =1  EXTERN xdata volatile BYTE ECC1B2            _AT_ 0xE62C;  // ECC1 Byte 2
 273      =1  EXTERN xdata volatile BYTE ECC2B0            _AT_ 0xE62D;  // ECC2 Byte 0
 274      =1  EXTERN xdata volatile BYTE ECC2B1            _AT_ 0xE62E;  // ECC2 Byte 1
 275      =1  EXTERN xdata volatile BYTE ECC2B2            _AT_ 0xE62F;  // ECC2 Byte 2
 276      =1  
 277      =1  // Feature Registers  (FX2LP/FX1 only)
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 11  

 278      =1  EXTERN xdata volatile BYTE GPCR2             _AT_ 0xE50D;  // Chip Features
 279      =1  
 280      =1  #undef EXTERN
 281      =1  #undef _AT_
 282      =1  
 283      =1  /*-----------------------------------------------------------------------------
 284      =1     Special Function Registers (SFRs)
 285      =1     The byte registers and bits defined in the following list are based
 286      =1     on the Synopsis definition of the 8051 Special Function Registers for EZ-USB. 
 287      =1      If you modify the register definitions below, please regenerate the file 
 288      =1      "ezregs.inc" which includes the same basic information for assembly inclusion.
 289      =1  -----------------------------------------------------------------------------*/
 290      =1  
 291      =1  sfr IOA     = 0x80;
 292      =1           /*  IOA  */
 293      =1           sbit PA0    = 0x80 + 0;
 294      =1           sbit PA1    = 0x80 + 1;
 295      =1           sbit PA2    = 0x80 + 2;
 296      =1           sbit PA3    = 0x80 + 3;
 297      =1  
 298      =1           sbit PA4    = 0x80 + 4;
 299      =1           sbit PA5    = 0x80 + 5;
 300      =1           sbit PA6    = 0x80 + 6;
 301      =1           sbit PA7    = 0x80 + 7;
 302      =1  sfr SP      = 0x81;
 303      =1  sfr DPL     = 0x82;
 304      =1  sfr DPH     = 0x83;
 305      =1  sfr DPL1    = 0x84;
 306      =1  sfr DPH1    = 0x85;
 307      =1  sfr DPS     = 0x86;
 308      =1           /*  DPS  */
 309      =1           // sbit SEL   = 0x86+0;
 310      =1  sfr PCON    = 0x87;
 311      =1           /*  PCON  */
 312      =1           //sbit IDLE   = 0x87+0;
 313      =1           //sbit STOP   = 0x87+1;
 314      =1           //sbit GF0    = 0x87+2;
 315      =1           //sbit GF1    = 0x87+3;
 316      =1           //sbit SMOD0  = 0x87+7;
 317      =1  sfr TCON    = 0x88;
 318      =1           /*  TCON  */
 319      =1           sbit IT0    = 0x88+0;
 320      =1           sbit IE0    = 0x88+1;
 321      =1           sbit IT1    = 0x88+2;
 322      =1           sbit IE1    = 0x88+3;
 323      =1           sbit TR0    = 0x88+4;
 324      =1           sbit TF0    = 0x88+5;
 325      =1           sbit TR1    = 0x88+6;
 326      =1           sbit TF1    = 0x88+7;
 327      =1  sfr TMOD    = 0x89;
 328      =1           /*  TMOD  */
 329      =1           //sbit M00    = 0x89+0;
 330      =1           //sbit M10    = 0x89+1;
 331      =1           //sbit CT0    = 0x89+2;
 332      =1           //sbit GATE0  = 0x89+3;
 333      =1           //sbit M01    = 0x89+4;
 334      =1           //sbit M11    = 0x89+5;
 335      =1           //sbit CT1    = 0x89+6;
 336      =1           //sbit GATE1  = 0x89+7;
 337      =1  sfr TL0     = 0x8A;
 338      =1  sfr TL1     = 0x8B;
 339      =1  sfr TH0     = 0x8C;
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 12  

 340      =1  sfr TH1     = 0x8D;
 341      =1  sfr CKCON   = 0x8E;
 342      =1           /*  CKCON  */
 343      =1           //sbit MD0    = 0x89+0;
 344      =1           //sbit MD1    = 0x89+1;
 345      =1           //sbit MD2    = 0x89+2;
 346      =1           //sbit T0M    = 0x89+3;
 347      =1           //sbit T1M    = 0x89+4;
 348      =1           //sbit T2M    = 0x89+5;
 349      =1  sfr SPC_FNC = 0x8F; // Was WRS in Reg320
 350      =1           /*  CKCON  */
 351      =1           //sbit WRS    = 0x8F+0;
 352      =1  sfr IOB     = 0x90;
 353      =1           /*  IOB  */
 354      =1           sbit PB0    = 0x90 + 0;
 355      =1           sbit PB1    = 0x90 + 1;
 356      =1           sbit PB2    = 0x90 + 2;
 357      =1           sbit PB3    = 0x90 + 3;
 358      =1  
 359      =1           sbit PB4    = 0x90 + 4;
 360      =1           sbit PB5    = 0x90 + 5;
 361      =1           sbit PB6    = 0x90 + 6;
 362      =1           sbit PB7    = 0x90 + 7;
 363      =1  sfr EXIF    = 0x91; // EXIF Bit Values differ from Reg320
 364      =1           /*  EXIF  */
 365      =1           //sbit USBINT = 0x91+4;
 366      =1           //sbit I2CINT = 0x91+5;
 367      =1           //sbit IE4    = 0x91+6;
 368      =1           //sbit IE5    = 0x91+7;
 369      =1  sfr MPAGE  = 0x92;
 370      =1  sfr SCON0  = 0x98;
 371      =1           /*  SCON0  */
 372      =1           sbit RI    = 0x98+0;
 373      =1           sbit TI    = 0x98+1;
 374      =1           sbit RB8   = 0x98+2;
 375      =1           sbit TB8   = 0x98+3;
 376      =1           sbit REN   = 0x98+4;
 377      =1           sbit SM2   = 0x98+5;
 378      =1           sbit SM1   = 0x98+6;
 379      =1           sbit SM0   = 0x98+7;
 380      =1  sfr SBUF0  = 0x99;
 381      =1  
 382      =1  #define AUTOPTR1H AUTOPTRH1 // for backwards compatibility with examples
 383      =1  #define AUTOPTR1L AUTOPTRL1 // for backwards compatibility with examples
 384      =1  #define APTR1H AUTOPTRH1 // for backwards compatibility with examples
 385      =1  #define APTR1L AUTOPTRL1 // for backwards compatibility with examples
 386      =1  
 387      =1  // this is how they are defined in the TRM
 388      =1  sfr AUTOPTRH1     = 0x9A; 
 389      =1  sfr AUTOPTRL1     = 0x9B; 
 390      =1  sfr AUTOPTRH2     = 0x9D;
 391      =1  sfr AUTOPTRL2     = 0x9E; 
 392      =1  
 393      =1  sfr IOC        = 0xA0;
 394      =1           /*  IOC  */
 395      =1           sbit PC0    = 0xA0 + 0;
 396      =1           sbit PC1    = 0xA0 + 1;
 397      =1           sbit PC2    = 0xA0 + 2;
 398      =1           sbit PC3    = 0xA0 + 3;
 399      =1  
 400      =1           sbit PC4    = 0xA0 + 4;
 401      =1           sbit PC5    = 0xA0 + 5;
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 13  

 402      =1           sbit PC6    = 0xA0 + 6;
 403      =1           sbit PC7    = 0xA0 + 7;
 404      =1  sfr INT2CLR    = 0xA1;
 405      =1  sfr INT4CLR    = 0xA2;
 406      =1  
 407      =1  sfr IE     = 0xA8;
 408      =1           /*  IE  */
 409      =1           sbit EX0   = 0xA8+0;
 410      =1           sbit ET0   = 0xA8+1;
 411      =1           sbit EX1   = 0xA8+2;
 412      =1           sbit ET1   = 0xA8+3;
 413      =1           sbit ES0   = 0xA8+4;
 414      =1           sbit ET2   = 0xA8+5;
 415      =1           sbit ES1   = 0xA8+6;
 416      =1           sbit EA    = 0xA8+7;
 417      =1  
 418      =1  sfr EP2468STAT     = 0xAA;
 419      =1           /* EP2468STAT */
 420      =1           //sbit EP2E   = 0xAA+0;
 421      =1           //sbit EP2F   = 0xAA+1;
 422      =1           //sbit EP4E   = 0xAA+2;
 423      =1           //sbit EP4F   = 0xAA+3;
 424      =1           //sbit EP6E   = 0xAA+4;
 425      =1           //sbit EP6F   = 0xAA+5;
 426      =1           //sbit EP8E   = 0xAA+6;
 427      =1           //sbit EP8F   = 0xAA+7;
 428      =1  
 429      =1  sfr EP24FIFOFLGS   = 0xAB;
 430      =1  sfr EP68FIFOFLGS   = 0xAC;
 431      =1  sfr AUTOPTRSETUP  = 0xAF;
 432      =1           /* AUTOPTRSETUP */
 433      =1           //   sbit EXTACC  = 0xAF+0;
 434      =1           //   sbit APTR1FZ = 0xAF+1;
 435      =1           //   sbit APTR2FZ = 0xAF+2;
 436      =1  
 437      =1  sfr IOD     = 0xB0;
 438      =1           /*  IOD  */
 439      =1           sbit PD0    = 0xB0 + 0;
 440      =1           sbit PD1    = 0xB0 + 1;
 441      =1           sbit PD2    = 0xB0 + 2;
 442      =1           sbit PD3    = 0xB0 + 3;
 443      =1  
 444      =1           sbit PD4    = 0xB0 + 4;
 445      =1           sbit PD5    = 0xB0 + 5;
 446      =1           sbit PD6    = 0xB0 + 6;
 447      =1           sbit PD7    = 0xB0 + 7;
 448      =1  sfr IOE     = 0xB1;
 449      =1  sfr OEA     = 0xB2;
 450      =1  sfr OEB     = 0xB3;
 451      =1  sfr OEC     = 0xB4;
 452      =1  sfr OED     = 0xB5;
 453      =1  sfr OEE     = 0xB6;
 454      =1  
 455      =1  sfr IP     = 0xB8;
 456      =1           /*  IP  */
 457      =1           sbit PX0   = 0xB8+0;
 458      =1           sbit PT0   = 0xB8+1;
 459      =1           sbit PX1   = 0xB8+2;
 460      =1           sbit PT1   = 0xB8+3;
 461      =1           sbit PS0   = 0xB8+4;
 462      =1           sbit PT2   = 0xB8+5;
 463      =1           sbit PS1   = 0xB8+6;
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 14  

 464      =1  
 465      =1  sfr EP01STAT    = 0xBA;
 466      =1  sfr GPIFTRIG    = 0xBB;
 467      =1                  
 468      =1  sfr GPIFSGLDATH     = 0xBD;
 469      =1  sfr GPIFSGLDATLX    = 0xBE;
 470      =1  sfr GPIFSGLDATLNOX  = 0xBF;
 471      =1  
 472      =1  sfr SCON1  = 0xC0;
 473      =1           /*  SCON1  */
 474      =1           sbit RI1   = 0xC0+0;
 475      =1           sbit TI1   = 0xC0+1;
 476      =1           sbit RB81  = 0xC0+2;
 477      =1           sbit TB81  = 0xC0+3;
 478      =1           sbit REN1  = 0xC0+4;
 479      =1           sbit SM21  = 0xC0+5;
 480      =1           sbit SM11  = 0xC0+6;
 481      =1           sbit SM01  = 0xC0+7;
 482      =1  sfr SBUF1  = 0xC1;
 483      =1  sfr T2CON  = 0xC8;
 484      =1           /*  T2CON  */
 485      =1           sbit CP_RL2 = 0xC8+0;
 486      =1           sbit C_T2  = 0xC8+1;
 487      =1           sbit TR2   = 0xC8+2;
 488      =1           sbit EXEN2 = 0xC8+3;
 489      =1           sbit TCLK  = 0xC8+4;
 490      =1           sbit RCLK  = 0xC8+5;
 491      =1           sbit EXF2  = 0xC8+6;
 492      =1           sbit TF2   = 0xC8+7;
 493      =1  sfr RCAP2L = 0xCA;
 494      =1  sfr RCAP2H = 0xCB;
 495      =1  sfr TL2    = 0xCC;
 496      =1  sfr TH2    = 0xCD;
 497      =1  sfr PSW    = 0xD0;
 498      =1           /*  PSW  */
 499      =1           sbit P     = 0xD0+0;
 500      =1           sbit FL    = 0xD0+1;
 501      =1           sbit OV    = 0xD0+2;
 502      =1           sbit RS0   = 0xD0+3;
 503      =1           sbit RS1   = 0xD0+4;
 504      =1           sbit F0    = 0xD0+5;
 505      =1           sbit AC    = 0xD0+6;
 506      =1           sbit CY    = 0xD0+7;
 507      =1  sfr EICON  = 0xD8; // Was WDCON in DS80C320; Bit Values differ from Reg320
 508      =1           /*  EICON  */
 509      =1           sbit INT6  = 0xD8+3;
 510      =1           sbit RESI  = 0xD8+4;
 511      =1           sbit ERESI = 0xD8+5;
 512      =1           sbit SMOD1 = 0xD8+7;
 513      =1  sfr ACC    = 0xE0;
 514      =1  sfr EIE    = 0xE8; // EIE Bit Values differ from Reg320
 515      =1           /*  EIE  */
 516      =1           sbit EUSB    = 0xE8+0;
 517      =1           sbit EI2C    = 0xE8+1;
 518      =1           sbit EIEX4   = 0xE8+2;
 519      =1           sbit EIEX5   = 0xE8+3;
 520      =1           sbit EIEX6   = 0xE8+4;
 521      =1  sfr B      = 0xF0;
 522      =1  sfr EIP    = 0xF8; // EIP Bit Values differ from Reg320
 523      =1           /*  EIP  */
 524      =1           sbit PUSB    = 0xF8+0;
 525      =1           sbit PI2C    = 0xF8+1;
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 15  

 526      =1           sbit EIPX4   = 0xF8+2;
 527      =1           sbit EIPX5   = 0xF8+3;
 528      =1           sbit EIPX6   = 0xF8+4;
 529      =1  
 530      =1  /*-----------------------------------------------------------------------------
 531      =1     Bit Masks
 532      =1  -----------------------------------------------------------------------------*/
 533      =1  
 534      =1  /* CPU Control & Status Register (CPUCS) */
 535      =1  #define bmPRTCSTB    bmBIT5
 536      =1  #define bmCLKSPD     (bmBIT4 | bmBIT3)
 537      =1  #define bmCLKSPD1    bmBIT4
 538      =1  #define bmCLKSPD0    bmBIT3
 539      =1  #define bmCLKINV     bmBIT2
 540      =1  #define bmCLKOE      bmBIT1
 541      =1  #define bm8051RES    bmBIT0
 542      =1  /* Port Alternate Configuration Registers */
 543      =1  /* Port A (PORTACFG) */
 544      =1  #define bmFLAGD      bmBIT7
 545      =1  #define bmINT1       bmBIT1
 546      =1  #define bmINT0       bmBIT0
 547      =1  /* Port C (PORTCCFG) */
 548      =1  #define bmGPIFA7     bmBIT7
 549      =1  #define bmGPIFA6     bmBIT6
 550      =1  #define bmGPIFA5     bmBIT5
 551      =1  #define bmGPIFA4     bmBIT4
 552      =1  #define bmGPIFA3     bmBIT3
 553      =1  #define bmGPIFA2     bmBIT2
 554      =1  #define bmGPIFA1     bmBIT1
 555      =1  #define bmGPIFA0     bmBIT0
 556      =1  /* Port E (PORTECFG) */
 557      =1  #define bmGPIFA8     bmBIT7
 558      =1  #define bmT2EX       bmBIT6
 559      =1  #define bmINT6       bmBIT5
 560      =1  #define bmRXD1OUT    bmBIT4
 561      =1  #define bmRXD0OUT    bmBIT3
 562      =1  #define bmT2OUT      bmBIT2
 563      =1  #define bmT1OUT      bmBIT1
 564      =1  #define bmT0OUT      bmBIT0
 565      =1  
 566      =1  /* I2C Control & Status Register (I2CS) */
 567      =1  #define bmSTART      bmBIT7
 568      =1  #define bmSTOP       bmBIT6
 569      =1  #define bmLASTRD     bmBIT5
 570      =1  #define bmID         (bmBIT4 | bmBIT3)
 571      =1  #define bmBERR       bmBIT2
 572      =1  #define bmACK        bmBIT1
 573      =1  #define bmDONE       bmBIT0
 574      =1  /* I2C Control Register (I2CTL) */
 575      =1  #define bmSTOPIE     bmBIT1
 576      =1  #define bm400KHZ     bmBIT0
 577      =1  /* Interrupt 2 (USB) Autovector Register (INT2IVEC) */
 578      =1  #define bmIV4        bmBIT6
 579      =1  #define bmIV3        bmBIT5
 580      =1  #define bmIV2        bmBIT4
 581      =1  #define bmIV1        bmBIT3
 582      =1  #define bmIV0        bmBIT2
 583      =1  /* USB Interrupt Request & Enable Registers (USBIE/USBIRQ) */
 584      =1  #define bmEP0ACK     bmBIT6
 585      =1  #define bmHSGRANT    bmBIT5
 586      =1  #define bmURES       bmBIT4
 587      =1  #define bmSUSP       bmBIT3
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 16  

 588      =1  #define bmSUTOK      bmBIT2
 589      =1  #define bmSOF        bmBIT1
 590      =1  #define bmSUDAV      bmBIT0
 591      =1  /* Breakpoint register (BREAKPT) */
 592      =1  #define bmBREAK      bmBIT3
 593      =1  #define bmBPPULSE    bmBIT2
 594      =1  #define bmBPEN       bmBIT1
 595      =1  /* Interrupt 2 & 4 Setup (INTSETUP) */
 596      =1  #define bmAV2EN      bmBIT3
 597      =1  #define INT4IN       bmBIT1
 598      =1  #define bmAV4EN      bmBIT0
 599      =1  /* USB Control & Status Register (USBCS) */
 600      =1  #define bmHSM        bmBIT7
 601      =1  #define bmDISCON     bmBIT3
 602      =1  #define bmNOSYNSOF   bmBIT2
 603      =1  #define bmRENUM      bmBIT1
 604      =1  #define bmSIGRESUME  bmBIT0
 605      =1  /* Wakeup Control and Status Register (WAKEUPCS) */
 606      =1  #define bmWU2        bmBIT7
 607      =1  #define bmWU         bmBIT6
 608      =1  #define bmWU2POL     bmBIT5
 609      =1  #define bmWUPOL      bmBIT4
 610      =1  #define bmDPEN       bmBIT2
 611      =1  #define bmWU2EN      bmBIT1
 612      =1  #define bmWUEN       bmBIT0
 613      =1  /* End Point 0 Control & Status Register (EP0CS) */
 614      =1  #define bmHSNAK      bmBIT7
 615      =1  /* End Point 0-1 Control & Status Registers (EP0CS/EP1OUTCS/EP1INCS) */
 616      =1  #define bmEPBUSY     bmBIT1
 617      =1  #define bmEPSTALL    bmBIT0
 618      =1  /* End Point 2-8 Control & Status Registers (EP2CS/EP4CS/EP6CS/EP8CS) */
 619      =1  #define bmNPAK       (bmBIT6 | bmBIT5 | bmBIT4)
 620      =1  #define bmEPFULL     bmBIT3
 621      =1  #define bmEPEMPTY    bmBIT2
 622      =1  /* Endpoint Status (EP2468STAT) SFR bits */
 623      =1  #define bmEP8FULL    bmBIT7
 624      =1  #define bmEP8EMPTY   bmBIT6
 625      =1  #define bmEP6FULL    bmBIT5
 626      =1  #define bmEP6EMPTY   bmBIT4
 627      =1  #define bmEP4FULL    bmBIT3
 628      =1  #define bmEP4EMPTY   bmBIT2
 629      =1  #define bmEP2FULL    bmBIT1
 630      =1  #define bmEP2EMPTY   bmBIT0
 631      =1  /* SETUP Data Pointer Auto Mode (SUDPTRCTL) */
 632      =1  #define bmSDPAUTO    bmBIT0
 633      =1  /* Endpoint Data Toggle Control (TOGCTL) */
 634      =1  #define bmQUERYTOGGLE  bmBIT7
 635      =1  #define bmSETTOGGLE    bmBIT6
 636      =1  #define bmRESETTOGGLE  bmBIT5
 637      =1  #define bmTOGCTLEPMASK bmBIT3 | bmBIT2 | bmBIT1 | bmBIT0
 638      =1  /* IBN (In Bulk Nak) enable and request bits (IBNIE/IBNIRQ) */
 639      =1  #define bmEP8IBN     bmBIT5
 640      =1  #define bmEP6IBN     bmBIT4
 641      =1  #define bmEP4IBN     bmBIT3
 642      =1  #define bmEP2IBN     bmBIT2
 643      =1  #define bmEP1IBN     bmBIT1
 644      =1  #define bmEP0IBN     bmBIT0
 645      =1  
 646      =1  /* PING-NAK enable and request bits (NAKIE/NAKIRQ) */
 647      =1  #define bmEP8PING     bmBIT7
 648      =1  #define bmEP6PING     bmBIT6
 649      =1  #define bmEP4PING     bmBIT5
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 17  

 650      =1  #define bmEP2PING     bmBIT4
 651      =1  #define bmEP1PING     bmBIT3
 652      =1  #define bmEP0PING     bmBIT2
 653      =1  #define bmIBN         bmBIT0
 654      =1  
 655      =1  /* Interface Configuration bits (IFCONFIG) */
 656      =1  #define bmIFCLKSRC    bmBIT7
 657      =1  #define bm3048MHZ     bmBIT6
 658      =1  #define bmIFCLKOE     bmBIT5
 659      =1  #define bmIFCLKPOL    bmBIT4
 660      =1  #define bmASYNC       bmBIT3
 661      =1  #define bmGSTATE      bmBIT2
 662      =1  #define bmIFCFG1      bmBIT1
 663      =1  #define bmIFCFG0      bmBIT0
 664      =1  #define bmIFCFGMASK   (bmIFCFG0 | bmIFCFG1)
 665      =1  #define bmIFGPIF      bmIFCFG1
 666      =1  
 667      =1  /* EP 2468 FIFO Configuration bits (EP2FIFOCFG,EP4FIFOCFG,EP6FIFOCFG,EP8FIFOCFG) */
 668      =1  #define bmINFM       bmBIT6
 669      =1  #define bmOEP        bmBIT5
 670      =1  #define bmAUTOOUT    bmBIT4
 671      =1  #define bmAUTOIN     bmBIT3
 672      =1  #define bmZEROLENIN  bmBIT2
 673      =1  #define bmWORDWIDE   bmBIT0
 674      =1  
 675      =1  /* Chip Revision Control Bits (REVCTL) - used to ebable/disable revision specidic
 676      =1     features */ 
 677      =1  #define bmNOAUTOARM    bmBIT1
 678      =1  #define bmSKIPCOMMIT   bmBIT0
 679      =1  
 680      =1  /* Fifo Reset bits (FIFORESET) */
 681      =1  #define bmNAKALL       bmBIT7
 682      =1  
 683      =1  /* Chip Feature Register (GPCR2) */
 684      =1  #define bmFULLSPEEDONLY    bmBIT4
 685      =1  
 686      =1  #endif   /* FX2REGS_H */
   5          #include "syncdly.h"            // SYNCDELAY macro
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      syncdly.h
   3      =1  //   Contents:  EZ-USB FX2 Synchronization Delay (SYNCDELAY) Macro
   4      =1  //                   Enter with _IFREQ = IFCLK in kHz
   5      =1  //                   Enter with _CFREQ = CLKOUT in kHz
   6      =1  //
   7      =1  // $Archive: /USB/Target/Inc/syncdly.h $
   8      =1  // $Date: 8/12/03 4:26p $
   9      =1  // $Revision: 2 $
  10      =1  //
  11      =1  //
  12      =1  //-----------------------------------------------------------------------------
  13      =1  // Copyright 2003, Cypress Semiconductor Corporation
  14      =1  //
  15      =1  // This software is owned by Cypress Semiconductor Corporation (Cypress) and is
  16      =1  // protected by United States copyright laws and international treaty provisions. Cypress
  17      =1  // hereby grants to Licensee a personal, non-exclusive, non-transferable license to copy,
  18      =1  // use, modify, create derivative works of, and compile the Cypress Source Code and
  19      =1  // derivative works for the sole purpose of creating custom software in support of Licensee
  20      =1  // product ("Licensee Product") to be used only in conjunction with a Cypress integrated
  21      =1  // circuit. Any reproduction, modification, translation, compilation, or representation of this
  22      =1  // software except as specified above is prohibited without the express written permission of
  23      =1  // Cypress.
  24      =1  //
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 18  

  25      =1  // Disclaimer: Cypress makes no warranty of any kind, express or implied, with regard to
  26      =1  // this material, including, but not limited to, the implied warranties of merchantability and
  27      =1  // fitness for a particular purpose. Cypress reserves the right to make changes without
  28      =1  // further notice to the materials described herein. Cypress does not assume any liability
  29      =1  // arising out of the application or use of any product or circuit described herein. Cypress
  30      =1  // products described herein are not authorized for use as components in life-support
  31      =1  // devices.
  32      =1  //
  33      =1  // This software is protected by and subject to worldwide patent coverage, including U.S.
  34      =1  // and foreign patents. Use may be limited by and subject to the Cypress Software License
  35      =1  // Agreement.
  36      =1  //-----------------------------------------------------------------------------
  37      =1  #include "intrins.h"
   1      =2  /*--------------------------------------------------------------------------
   2      =2  INTRINS.H
   3      =2  
   4      =2  Intrinsic functions for C51.
   5      =2  Copyright (c) 1988-2004 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __INTRINS_H__
  10      =2  #define __INTRINS_H__
  11      =2  
  12      =2  extern void          _nop_     (void);
  13      =2  extern bit           _testbit_ (bit);
  14      =2  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =2  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =2  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =2  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =2  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =2  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =2  extern unsigned char _chkfloat_(float);
  21      =2  extern void          _push_    (unsigned char _sfr);
  22      =2  extern void          _pop_     (unsigned char _sfr);
  23      =2  
  24      =2  #endif
  25      =2  
  38      =1  
  39      =1    // Registers which require a synchronization delay, see section 15.14
  40      =1    // FIFORESET        FIFOPINPOLAR
  41      =1    // INPKTEND         OUTPKTEND
  42      =1    // EPxBCH:L         REVCTL
  43      =1    // GPIFTCB3         GPIFTCB2
  44      =1    // GPIFTCB1         GPIFTCB0
  45      =1    // EPxFIFOPFH:L     EPxAUTOINLENH:L
  46      =1    // EPxFIFOCFG       EPxGPIFFLGSEL
  47      =1    // PINFLAGSxx       EPxFIFOIRQ
  48      =1    // EPxFIFOIE        GPIFIRQ
  49      =1    // GPIFIE           GPIFADRH:L
  50      =1    // UDMACRCH:L       EPxGPIFTRIG
  51      =1    // GPIFTRIG
  52      =1    
  53      =1    // Note: The pre-REVE EPxGPIFTCH/L register are affected, as well...
  54      =1    //      ...these have been replaced by GPIFTC[B3:B0] registers
  55      =1  
  56      =1  // _IFREQ can be in the range of: 5000 to 48000
  57      =1  #ifndef _IFREQ 
  58      =1  #define _IFREQ 48000   // IFCLK frequency in kHz
  59      =1  #endif
  60      =1  
  61      =1  // CFREQ can be any one of: 48000, 24000, or 12000
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 19  

  62      =1  #ifndef _CFREQ
  63      =1  #define _CFREQ 48000   // CLKOUT frequency in kHz
  64      =1  #endif
  65      =1  
  66      =1  #if( _IFREQ < 5000 )
           =1 #error "_IFREQ too small!  Valid Range: 5000 to 48000..."
           =1 #endif
  69      =1  
  70      =1  #if( _IFREQ > 48000 )
           =1 #error "_IFREQ too large!  Valid Range: 5000 to 48000..."
           =1 #endif
  73      =1  
  74      =1  #if( _CFREQ != 48000 )
           =1 #if( _CFREQ != 24000 )
           =1 #if( _CFREQ != 12000 )
           =1 #error "_CFREQ invalid!  Valid values: 48000, 24000, 12000..."
           =1 #endif
           =1 #endif
           =1 #endif
  81      =1  
  82      =1  // Synchronization Delay formula: see TRM section 15-14
  83      =1  #define _SCYCL ( 3*(_CFREQ) + 5*(_IFREQ) - 1 ) / ( 2*(_IFREQ) )
  84      =1  
  85      =1  #if( _SCYCL == 1 )
           =1 #define SYNCDELAY _nop_( )
           =1 #endif
  88      =1  
  89      =1  #if( _SCYCL == 2 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( )
           =1 #endif
  93      =1  
  94      =1  #if( _SCYCL == 3 )
  95      =1  #define SYNCDELAY _nop_( ); \
  96      =1                    _nop_( ); \
  97      =1                    _nop_( ) 
  98      =1  #endif
  99      =1  
 100      =1  #if( _SCYCL == 4 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 106      =1  
 107      =1  #if( _SCYCL == 5 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 114      =1  
 115      =1  #if( _SCYCL == 6 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 123      =1  
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 20  

 124      =1  #if( _SCYCL == 7 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 133      =1  
 134      =1  #if( _SCYCL == 8 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 144      =1  
 145      =1  #if( _SCYCL == 9 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 156      =1  
 157      =1  #if( _SCYCL == 10 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 169      =1  
 170      =1  #if( _SCYCL == 11 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 183      =1  
 184      =1  #if( _SCYCL == 12 )
           =1 #define SYNCDELAY _nop_( ); \
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 21  

           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 198      =1  
 199      =1  #if( _SCYCL == 13 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 214      =1  
 215      =1  #if( _SCYCL == 14 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 231      =1  
 232      =1  #if( _SCYCL == 15 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 22  

           =1 #endif
 249      =1  
 250      =1  #if( _SCYCL == 16 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
   6          #include "pins_def.h"
   1      =1  #ifndef PINS_DEF_H              //Header sentry
   2      =1  #define PINS_DEF_H
   3      =1  
   4      =1  // PINS FUNCTIONS DEFINITIONS
   5      =1  
   6      =1  // PORT BIT DEFINITIONS : OUTPUTS
   7      =1  //#define USB_LED_PORT_OUT              OUTB    // USB Led output pin
   8      =1  //#define USB_LED_PIN                   bmBIT6  // USB Led
   9      =1  #define Z8_RESET_PORT_OUT               IOE             // Reset control of Z8 board
  10      =1  #define Z8_RESET_PIN                    bmBIT1  // Reset control of Z8 board
  11      =1  #define OCD_EN_PORT_OUT                 IOE             // OCD Enable output port
  12      =1  #define OCD_EN_PIN                              bmBIT0  // OCD Enable output pin
  13      =1  #define FORCE_OCD_Z8_PORT_OUT   IOE             // Reset control of Z8 board
  14      =1  #define FORCE_OCD_Z8_PIN                bmBIT3  // Reset control of Z8 board
  15      =1  
  16      =1  // PORT BIT DEFINITIONS : INPUTS
  17      =1  #define VUSB_PORT_IN                    IOE             // usb power supply monitor input port
  18      =1  #define VUSB_PIN                                bmBIT2  // usb power supply monitor input pin
  19      =1  
  20      =1  
  21      =1  // OPTIONAL PINS ACTUALLY NOT USED
  22      =1  
  23      =1  
  24      =1  #endif
  25      =1  
  26      =1  
  27      =1  
  28      =1  
  29      =1  
   7          #include "common_def.h"
   1      =1  #ifndef COMMON_DEF_H            //Header sentry
   2      =1  #define COMMON_DEF_H
   3      =1  
   4      =1  // GLOBAL DEFINES
   5      =1  // #define EZ_COMPIL 1
   6      =1  
   7      =1  //#define SIMUL 1
   8      =1  
   9      =1  // MIDI MERGERS BUFFERS LENGHT
  10      =1  #define MIDI_IN_FROM_CON_BUFF_LENGHT    128     // V1.5 128
  11      =1  #define MIDI_IN_FROM_USB_BUFF_LENGHT    128 // V1.5 128
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 23  

  12      =1  #define SERIAL_IN_FROM_Z8_BUFF_LENGHT   128 // V1.5 128 
  13      =1  #define MIDI_IN_REALTIME_BUFF_LENGHT    8
  14      =1  
  15      =1  typedef struct {
  16      =1  BYTE start_index;                                                       // start index on input buffer
  17      =1  volatile BYTE end_index;                                        // end index on input buffer
  18      =1  BYTE merger_state;                                                      // merger state of input buffer
  19      =1  volatile BYTE current_index;                            // current index on input buffer
  20      =1  volatile BYTE input_status;                                     // Status register : see bits definition below
  21      =1  BYTE buffer[MIDI_IN_FROM_CON_BUFF_LENGHT];      // input buffer
  22      =1  } Midi_In_Struct;
  23      =1  
  24      =1  
  25      =1  // bits definition for input_status in the aove structure
  26      =1  #define input_overflow                  (1 << 0)        // bit 0 : input overflow
  27      =1  
  28      =1  typedef struct {
  29      =1  BYTE realtime[MIDI_IN_REALTIME_BUFF_LENGHT];// realtime midi input buffer
  30      =1  BYTE realtime_start_index;                                      // current index on realtime buffer
  31      =1  BYTE realtime_end_index;                                        // current index on realtime buffer
  32      =1  volatile BYTE input_status;                                     // Status register : see bits definition below
  33      =1  } Midi_In_Realtime_Struct;
  34      =1  
  35      =1  // bits definition for input_status in the above realtime structure
  36      =1  #define realtime_overflow               (1 << 0)        // bit 0 : realtime input overflow
  37      =1  
  38      =1  // enums for the following registers updated from Z8 board
  39      =1  // enum {CTRL_REG_0_7BITS_FROM_Z8,CTRL_REG_1_7BITS_FROM_Z8  };
  40      =1  
  41      =1  #endif
   8          #include <common_z8_ez.h>
   1      =1  #ifndef COMMON_Z8_EZ
   2      =1  #define COMMON_Z8_EZ
   3      =1  
   4      =1  typedef unsigned char uchar;
   5      =1  typedef unsigned int  uint;
   6      =1  
   7      =1  #define Z8_FREQ 20000000ul      // 20.0 MHz
   8      =1  
   9      =1  #define BAUD_Z8_EZ                              31250L                  // 62.5K baud for UART0
  10      =1  #define BAUD_OCD_Z8_EZ                  62500L                  // 62.5K baud for Z8 On Chip debugger (Must be > 39kb at 20MHz)
  11      =1  
  12      =1  
  13      =1  // #define HW_V10       1 // uncoment only if hw v1.0 (usb monitor pin and cancel pins are inverted)
  14      =1  
  15      =1  #define FW_VERSION_INDEX                0U
  16      =1  #define FW_SUB_VERSION_INDEX    1U
  17      =1  #define HW_VERSION_INDEX                2U
  18      =1  #define HW_SUB_VERSION_INDEX    3U
  19      =1  #define MANUF_YEAR_INDEX                4U
  20      =1  #define MANUF_MONTH_INDEX               5U
  21      =1  #define SERIAL_4_INDEX                  6U
  22      =1  #define SERIAL_3_INDEX                  7U
  23      =1  #define SERIAL_2_INDEX                  8U
  24      =1  #define SERIAL_1_INDEX                  9U
  25      =1  #define SERIAL_0_INDEX                  10U
  26      =1  
  27      =1  #define IDENTITY_LENGHT                 11
  28      =1  
  29      =1  // Z8_STATUS_0_NVM bits definition (MUST BE LOADED From NVM AT STARTUP)
  30      =1  // bit 7 always 0
  31      =1  #define new_video_mode_z0nvm            (1<<6)  // 1 = inverted
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 24  

  32      =1  #define video_mode_z0nvm                        (1<<5)  // 1 = inverted
  33      =1  #define encoder_tempo_lock_z0nvm        (1<<4)  // 1 = lock tempo encoder
  34      =1  #define mtc_mode_on_off_z0nvm           (1<<3)  // 1 = realtime off, 0 = realtime on    DO NOT CHANGE ORDER
  35      =1  #define mtc_mode_z0nvm                          (1<<2)  // 1 = mtc / 0 = midi clock                             DO NOT CHANGE ORDER
  36      =1  #define hook_zjump_mode_z0nvm           (1<<1)  // 1 = jumpless
  37      =1  #define jog_lock_z0nvm                          (1<<0)  // 1 = lock big encoder
  38      =1  
  39      =1  #define MTC_MODE_MASK_BIT       0x0C    // Bits 2 & 3
  40      =1  
  41      =1  // Z8_STATUS_1_NVM bits definition (MUST BE LOADED From NVM AT STARTUP)
  42      =1  // bit 7 always 0
  43      =1  #define must_autoassign_z1nvm           (1<<6)  // 1 = must auto assign
  44      =1  #define smpte_frame_rate_1_z1nvm        (1<<2)  // 0 0 = 24 fps         0 1 = 25 fps            DO NOT CHANGE ORDER
  45      =1  #define smpte_frame_rate_0_z1nvm        (1<<1)  // 1 0 = 30 fps nd      1 1 = 30 fps            DO NOT CHANGE ORDER
  46      =1  
  47      =1  #define SMPTE_FRAME_RATE_MASK_BIT       0x06    // Bits 1 & 2
  48      =1  
  49      =1  // Z8_STATUS_2_NVM bits definition (MUST BE LOADED From NVM AT STARTUP)
  50      =1  // bit 7 always 0
  51      =1  
  52      =1  ////////////////////////////////////////////////////////////////////////////////////////////////////////
  53      =1  /////////////////////////// REGISTERS THAT MUST BE SENT TO EZ AT STARTUP ///////////////////////////////
  54      =1  
  55      =1  // CTRL_REG_0_7BITS_TO_EZ bits definition (MUST BE LOADED From NVM AT STARTUP, MUST BE SENT TO EZBOARD)
  56      =1  // Bit 7 must be 0 since this control reg is sent to EZBOARD
  57      =1  #define filter_state_z_ez0_bit_pos                              6       
  58      =1  //#define                                                                               5       
  59      =1  #define filter_type_z_ez0_bit_pos                               4
  60      =1  #define midi_thru_ez0_bit_pos                                   3       
  61      =1  //#define merger_src_midi_in_state_z_ez0_bit_pos        3
  62      =1  //#define merger_src_usb_in_state_z_ez0_bit_pos 2
  63      =1  //#define merger_dst_usb_out_state_z_ez0_bit_pos        1
  64      =1  //#define merger_dst_out1_state_z_ez0_bit_pos           0
  65      =1  
  66      =1  #ifdef Z8_COMPIL
           =1 #define filter_state_z_ez0                                      (1<<filter_state_z_ez0_bit_pos)                         // on/off
           =1 // #define 
           =1 #define filter_type_z_ez0                                       (1<<filter_type_z_ez0_bit_pos)                          // 1=filter all, 0=filter realtime
           =1 #define midi_thru_ez0                                           (1<<midi_thru_ez0_bit_pos)      // on/off
           =1 //#define merger_src_midi_in_state_z_ez0        (1<<merger_src_midi_in_state_z_ez0_bit_pos)     // on/off
           =1 //#define merger_src_usb_in_state_z_ez0         (1<<merger_src_usb_in_state_z_ez0_bit_pos)      // on/off
           =1 //#define merger_dst_usb_out_state_z_ez0        (1<<merger_dst_usb_out_state_z_ez0_bit_pos)     // on/off
           =1 //#define merger_dst_out1_state_z_ez0           (1<<merger_dst_out1_state_z_ez0_bit_pos)        // on/off
           =1 #endif
  76      =1  
  77      =1  #ifdef EZ_COMPIL
  78      =1  #define filter_state_z_ez0                                      (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ filter_state_z_ez0
             -_bit_pos)
  79      =1  // #define 
  80      =1  #define filter_type_z_ez0                                       (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ filter_type_z_ez0_b
             -it_pos)
  81      =1  #define midi_thru_ez0                                           (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ midi_thru_ez0_bit_pos)
  82      =1  //#define merger_src_midi_in_state_z_ez0        (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ merger_
             -src_midi_in_state_z_ez0_bit_pos)
  83      =1  //#define merger_src_usb_in_state_z_ez0         (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ merger_s
             -rc_usb_in_state_z_ez0_bit_pos)
  84      =1  //#define merger_dst_usb_out_state_z_ez0        (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ merger_d
             -st_usb_out_state_z_ez0_bit_pos)
  85      =1  //#define merger_dst_out1_state_z_ez0           (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_0_7BITS_TO_EZ_INDEX] ^ merger_dst
             -_out1_state_z_ez0_bit_pos)
  86      =1  #endif
  87      =1  
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 25  

  88      =1  
  89      =1  // CTRL_REG_1_7BITS_TO_EZ bits definition (MUST BE LOADED From NVM AT STARTUP, MUST BE SENT TO EZBOARD)
  90      =1  // Bit 7 must be 0 since this control reg is sent to EZBOARD
  91      =1  #define ez_fw_midi_to_z8_z_ez1_bit_pos          4       // V1.5 ; z8 indicates to EZ it must receive midi events
  92      =1  #define realtime_source_int_z_ez1_bit_pos       1       // DO NOT CHANGE ORDER
  93      =1  #define realtime_source_ext_z_ez1_bit_pos       0       // DO NOT CHANGE ORDER
  94      =1  #define REALTIME_SRC_MSK        0x03                            // Midi in, Usb in, internal
  95      =1  
  96      =1  #ifdef Z8_COMPIL
           =1 #define ez_fw_midi_to_z8_z_ez1                          (1<<ez_fw_midi_to_z8_z_ez1_bit_pos)             // on/off
           =1 #define realtime_source_int_z_ez1                       (1<<realtime_source_int_z_ez1_bit_pos)  // 0=internal 0ff, 1=internal o
             -n 
           =1 #define realtime_source_ext_z_ez1                       (1<<realtime_source_ext_z_ez1_bit_pos)  // 0=midi in, 1=usb in (externa
             -l sync input)
           =1 #endif
 101      =1  
 102      =1  #ifdef EZ_COMPIL
 103      =1  #define ez_fw_midi_to_z8_z_ez1                          (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_1_7BITS_TO_EZ_INDEX] ^ ez_fw_midi_to_z
             -8_z_ez1_bit_pos)
 104      =1  #define realtime_source_int_z_ez1                       (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_1_7BITS_TO_EZ_INDEX] ^ realtime_sour
             -ce_int_z_ez1_bit_pos)
 105      =1  #define realtime_source_ext_z_ez1                       (CTRL_REGS_7BITS_FROM_Z8[CTRL_REG_1_7BITS_TO_EZ_INDEX] ^ realtime_sour
             -ce_ext_z_ez1_bit_pos)
 106      =1  #endif
 107      =1  
 108      =1  // LAST_CTRL_REG_7BITS_TO_EZ_INDEX bits definition (MUST BE LOADED From NVM AT STARTUP, MUST BE SENT TO EZ
             -BOARD)
 109      =1  // Bit 7 must be 0 since this control reg is sent to EZBOARD
 110      =1  //#define ez_board_fully_updated_ezlast         (1<<6)  // 1 when all regs dedicated to EZ have been sent
 111      =1  // or
 112      =1  #define EZ_FULLY_UPDATED        0x55U
 113      =1  
 114      =1  ////////////////////////////////////////////////////////////////////////////////////////////////////////
 115      =1  // MISC REGISTERS (PARTIALY) USED BY EZ BOARD, NOT TO SEND (COMMON DEF ONLY)
 116      =1  ////////////////////////////////////////////////////////////////////////////////////////////////////////
 117      =1  
 118      =1  // Z8_STATUS_8 bits definition
 119      =1  #define onewire_rx_overflow_z8                  (1<<5)  // 0 =no overflow               DO NOT CHANGE ORDER
 120      =1  #define serial_in_overflow_z8                   (1<<4)  // 0 =no overflow               DO NOT CHANGE ORDER
 121      =1  #define midi_in_realtime_overflow_z8    (1<<3)  // 0 =no overflow               DO NOT CHANGE ORDER
 122      =1  #define usb_in_realtime_overflow_z8             (1<<2)  // 0 =no overflow               DO NOT CHANGE ORDER
 123      =1  #define midi_in_overflow_z8                             (1<<1)  // 0 =no overflow               DO NOT CHANGE ORDER
 124      =1  #define usb_in_overflow_z8                              (1<<0)  // 0 =no overflow               DO NOT CHANGE ORDER
 125      =1  
 126      =1  #define OVERFLOW_MSK                                    0x3FU   // mask bits 0-5
 127      =1  #define OVERFLOW_FROM_EZ_MSK                    0x0FU   // mask bits 0-3 (only overflows from EZ board)
 128      =1  #define OVERFLOW_REALTIME_MSK                   0x0CU   // mask bits 3-2
 129      =1  #define OVERFLOW_INPUT_MSK                              0x03U   // mask bits 1-0
 130      =1  #define OVERFLOW_FROM_MIDI_MSK                  0x0AU   // mask bits 1 and 3
 131      =1  #define OVERFLOW_FROM_USB_MSK                   0x05U   // mask bits 0 and 2
 132      =1  
 133      =1  //////////////////////////////////////////////////////////
 134      =1  // Z8 TO EZ (only) COMMUNICATION PROTOCOL ////////////////
 135      =1  //////////////////////////////////////////////////////////
 136      =1  #define SOF_TO_EZ                                               0xFFU
 137      =1  #define FRAME_FROM_Z8_TO_EZ_TYPE_MSK    0x60U   // Bits 6-5 : data type (reg/midi)
 138      =1  #define FRAME_TO_EZ_IS_MIDI                             0x20U
 139      =1  #define FRAME_TO_EZ_IS_CTRL_REG                 0x00U
 140      =1  #define EOF_TO_EZ                                               0xFEU
 141      =1  
 142      =1  // frame from z8 to ez status byte bits definition
 143      =1  // bit 7 is always 0                                    //  bit 7 : always 0
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 26  

 144      =1  // bits 6:5                                                     // frame type 00=ctrl_reg 01=midi 
 145      =1  #define send_to_usb                     (1 << 4)        // bit 4        // reg address or send to usb
 146      =1  #define send_to_out1            (1 << 3)        // bit 3        // reg address or send to out 0
 147      =1  #define send_to_out2            (1 << 2)        // bit 2        // reg address or send to out 1
 148      =1  // bits 1:0                                                             // bits 1:0     // reg address or rfu
 149      =1  
 150      =1  #define CTRL_REG_Z8_TO_EZ_ADDR_MSK              0x1F
 151      =1  
 152      =1  //////////////////////////////////////////////////////////
 153      =1  // EZ TO Z8 (only) COMMUNICATION PROTOCOL ////////////////
 154      =1  //////////////////////////////////////////////////////////
 155      =1  
 156      =1  #define CTRL_REG_MAX_FROM_EZ_TO_Z8              1U              // Nb of registers updated to the Z8 board
 157      =1  
 158      =1  // CTRL_REG_0_7BITS_FROM_EZ bits definition : TOGGLE REGISTER
 159      =1  // the following bits def MUST be duplicated in main.c from EZ project file
 160      =1  //  bit 7 is always 0                                                   //  bit 7 : always 0
 161      =1  #define usb_state_from_ez0_bit_pos                                      6
 162      =1  #define z8_board_fully_updated_from_ez0_bit_pos         5
 163      =1  #define must_start_bootloader_from_ez0_bit_pos          4
 164      =1  #define usb_enumrated_from_ez0_bit_pos                          3
 165      =1  
 166      =1  #ifdef Z8_COMPIL
           =1 #define usb_state_from_ez0                                      (1<<usb_state_from_ez0_bit_pos) // 0=midi in, 1=usb in
           =1 #define z8_board_fully_updated_from_ez0         (1<<z8_board_fully_updated_from_ez0_bit_pos)    // on/off
           =1 #define must_start_bootloader_from_ez0          (1<<must_start_bootloader_from_ez0_bit_pos)     // on/off
           =1 #define usb_enumrated_from_ez0                          (1<<usb_enumrated_from_ez0_bit_pos)     // on/off
           =1 #endif
 172      =1  
 173      =1  #ifdef EZ_COMPIL
 174      =1  #define usb_state_from_ez0                                      (CTRL_REGS_7BITS_TO_Z8[0] ^ usb_state_from_ez0_bit_pos)
 175      =1  #define z8_board_fully_updated_from_ez0         (CTRL_REGS_7BITS_TO_Z8[0] ^ z8_board_fully_updated_from_ez0_bit_
             -pos)
 176      =1  #define must_start_bootloader_from_ez0          (CTRL_REGS_7BITS_TO_Z8[0] ^ must_start_bootloader_from_ez0_bit_pos
             -)
 177      =1  #define usb_enumrated_from_ez0                          (CTRL_REGS_7BITS_TO_Z8[0] ^ usb_enumrated_from_ez0_bit_pos)
 178      =1  #endif
 179      =1  
 180      =1  // SYSEX ID0 (BYTE 6)   
 181      =1  //  bit 7 is always 0                                                   //  bit 7 : always 0
 182      =1  #define sysex_direction_sysxid0                 (1<<6U) //  bit 6 :                                                     0=received sysex, 1=sent sysex
 183      =1  #define prog_upload_sysxid0                             (1<<5U) //      bit 5 : program or upload request       0=program request/answer 1=upl
             -oad request/answer
 184      =1  #define prog_ez_z8_sysxid0                              (1<<5U) //      bit 5 : 0= program ez firmware 1= program z8 firmware 
 185      =1  #define pure_midi_from_usb_sysxid0              (1<<5U) //      bit 5 : 0= pure midi from MIDI in conn 1= pure Midi from US
             -B in (V1.5)
 186      =1  #define acknoledge_sysxid0                              (1<<4U) //      bit 4 : ack request/answer                      0=no ack required/prog error  1=ack 
             -required/prog succeeded
 187      =1  #define checksum_check_sysxid0                  (1<<3U) //      bit 3 : checksum check request          0=no checksum to check  1=must
             - check embedeed checksum (calculated from SYSEX ID2 to checksum)
 188      =1  //#define checksum_return_sysxid0               (1<<2U) //      bit 2 : checksum return request         0=checksum return is not re
             -quested 1:checksum return is requested 
 189      =1  #define fw_znext_finish_sysxid0                 (1<<2U) //      bit 2 : 0= next firmware data available / 1=finish programmin
             -g firmware
 190      =1  // bits 1:0 : frame type content                                //  00=common parameter 01=lcd control assign   // DO NOT CHANGE ORDER
 191      =1                                                                                                  //  10=firmware or midi 11=midi control assign  // DO NOT CHANGE ORDER
 192      =1  #define FRAME_TO_Z8_TYPE_MSK                    0x03U   //      sysex content 
 193      =1                                                  
 194      =1  //v1.1 enum { FRAME_IS_COMMON_PARAM, FRAME_IS_LCD_CTRL_ASSIGN, FRAME_IS_FIRMWARE, FRAME_IS_MIDI_CTRL_ASSIG
             -N, FRAME_IS_PURE_MIDI};
 195      =1  enum { FRAME_IS_COMMON_PARAM, FRAME_IS_LCD_CTRL_ASSIGN, FRAME_IS_FIRMWARE_OR_PURE_MIDI, FRAME_IS_MIDI_CTRL
             -_ASSIGN};
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 27  

 196      =1  
 197      =1  // Addresses of common parameters uploaded/programmed from EZ board or external sysex
 198      =1  enum {  // then with NVM regs dedicated to EZ board
 199      =1                  CTRL_REG_0_7BITS_TO_EZ_INDEX, CTRL_REG_1_7BITS_TO_EZ_INDEX, 
 200      =1                  LAST_CTRL_REG_7BITS_TO_EZ_INDEX,
 201      =1                  // continue with NVM regs dedicated to Z8 only
 202      =1                  Z8_STATUS_0_NVM_INDEX, Z8_STATUS_1_NVM_INDEX, CHANNEL_INDEX, GROUP_INDEX, INT_TEMPO_INDEX, 
 203      =1          // the following regs cannot be accessed (from EZ board only)
 204      =1          CTRL_REG_0_7B_FROM_EZ_INDEX, LCD_MESSAGE_TO_Z8_INDEX };
 205      =1  
 206      =1  #define IDENTITY_REQUEST_INDEX 0x7F
 207      =1  
 208      =1  // first index of NVM registers dedicated to EZ
 209      =1  #define CTRL_REG_TO_EZ_START_INDEX       CTRL_REG_0_7BITS_TO_EZ_INDEX   
 210      =1  // last index of NVM register that can be programmed by external sysex
 211      =1  
 212      =1  // last index of NVM register that can be programmed by external sysex or EZ board
 213      =1  #define LAST_COMMON_PARAM_INDEX      LCD_MESSAGE_TO_Z8_INDEX
 214      =1  // Nb of registers updated from the Z8 board
 215      =1  #define CTRL_REG_NB_FROM_Z8_TO_EZ        (LAST_CTRL_REG_7BITS_TO_EZ_INDEX-CTRL_REG_0_7BITS_TO_EZ_INDEX+1)               
 216      =1  
 217      =1  //SYSEX ID3 (BYTE 8)    
 218      =1  //  bit 7               : always 0
 219      =1  //      bits 6:0        : group or address      : control assign group GG
 220      =1   
 221      =1  // JLABS SYSEX header from MMA
 222      =1  #define JLABS_SYX_ID0                           0x00U
 223      =1  #define JLABS_SYX_ID1                           0x20U
 224      =1  #define JLABS_SYX_ID2                           0x4FU
 225      =1  #define JLABS_SYX_ID3                           0x00U
 226      =1  #define JLABS_SYX_ID4                           0x01U
 227      =1  
 228      =1  #define MIDI_PROGRAM_CHANGE                     0xC0U
 229      =1  #define MIDI_CONTROL_CHANGE                     0xB0U
 230      =1  #define MIDI_PITCH_WHEEL                        0xE0U
 231      =1  #define MIDI_CHANN_PRESSURE                     0xD0U
 232      =1  #define MIDI_NOTE_ON                            0x90U
 233      =1  #define MIDI_NOTE_OFF                           0x80U
 234      =1  #define MIDI_MMC_PAUSE                          0x09U
 235      =1  #define MIDI_MMC_BACKWARD                       0x05U
 236      =1  #define MIDI_MMC_FORWARD                        0x04U
 237      =1  #define MIDI_MMC_PLAY                           0x02U
 238      =1  #define MIDI_MMC_STOP                           0x01U
 239      =1  #define MIDI_MMC_REC                            0x06U
 240      =1  #define MIDI_CLOCK                                      0xF8U
 241      =1  #define MIDI_TICK                                       0xF9U
 242      =1  #define MIDI_START                                      0xFAU
 243      =1  #define MIDI_CONTINUE                           0xFBU
 244      =1  #define MIDI_STOP                                       0xFCU
 245      =1  #define MIDI_SOX                                        0xF0U
 246      =1  #define MIDI_EOX                                        0xF7U
 247      =1  #define MIDI_ACTIVE_SENSE                       0xFEU   // never received, filtered by EZ board
 248      =1  #define MIDI_TIME_CODE                          0xF1U
 249      =1  #define MIDI_SONG_POSITION_POINTER      0xF2U
 250      =1  #define MIDI_SONG_SELECTED                      0xF3U
 251      =1  #define MIDI_STATUS_MASK                        0x80U
 252      =1  
 253      =1  #define JLABS_SYX_HEADER_SIZE                   6U                                                              // f0 00 20 4f 00 01 
 254      =1  #define JLABS_SYX_UPLOAD_HEADER_SIZE    (JLABS_SYX_HEADER_SIZE + 4U)    // f0 00 20 4f 00 01 UL LL GG NN 
 255      =1  
 256      =1  #define DATA_LENGHT_START_BOOTLOADER    0x7F
 257      =1  #define Z8_ERASING_TIME                                 4000
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 28  

 258      =1  #define EE_24C64_PAGE_LENGHT                    32
 259      =1  #define EE24C64_SIZE                                    16384
 260      =1  
 261      =1  #define MAX_LCD_TEXT_LENGHT                     (16U + 1U)              // 16 chars + eoc
 262      =1  
 263      =1  
 264      =1  #define DEFAULT_INTERNAL_TEMPO          100 // 30 will be added : 130
 265      =1  #define MAX_REAL_TEMPO                          255
 266      =1  #define TEMPO_ADD_OFFSET                        30
 267      =1  
 268      =1  #endif
   9          #include "usb.h"
   1      =1  #ifndef USB_H           //Header sentry
   2      =1  #define USB_H
   3      =1  
   4      =1  
   5      =1  
   6      =1  // PROTOTYPES
   7      =1  void Check_If_Usb_Attached(void);
   8      =1  void Check_Usb(void);
   9      =1  void Create_Send_USB_Frame_From_MIDI_Buffer( BYTE CN, Midi_In_Struct *midi_struct, BYTE end_index_local);
  10      =1  void Create_Send_Realtime_USB_Frame_From_MIDI_Buffer( BYTE CN, BYTE realtime_data);
  11      =1  void Ep2out_Function(void);
  12      =1  #endif
  10          #include "usb_defs.h"
   1      =1  #ifndef USB_DEFS_H              //Header sentry
   2      =1  #define USB_DEFS_H
   3      =1  
   4      =1  // MIDI-USB DEFINITIONS
   5      =1  #define MIDI_USB_FRAME_LENGHT           0x04
   6      =1  #define USB_EP_BUFFER_LENGHT                    64
   7      =1  
   8      =1  // USB MIDI IN  IS ON ENDPOINT 2 (OUT2)
   9      =1  // USB MIDI OUT IS ON ENDPOINT 4 (IN4)
  10      =1  
  11      =1  /*
  12      =1  #define USB_IN_USES_ENDPOINT                    1 // 2
  13      =1  
  14      =1  #if USB_IN_USES_ENDPOINT == 1
  15      =1  #define USB_IN_ID                               IN1BUF_ID       // use endpoint 1
  16      =1  #define USB_IN_BUFFER                   EP1INBUF        // IN1BUF               // use endpoint 1
  17      =1  #define USB_PAIRED_EP                   0x08            // enpoint 2 out paired
  18      =1  #define USB_ITRS_EP_IN                  bmEP1           // itr on in ep1 is used
  19      =1  #define USB_EP_IN_DESC                  0x81                            
  20      =1  #endif
  21      =1  
  22      =1  #if USB_IN_USES_ENDPOINT == 2
  23      =1  #define USB_IN_ID                               IN2BUF_ID       // use endpoint 2
  24      =1  #define USB_IN_BUFFER                   EP2INBUF        // IN2BUF               // use endpoint 2
  25      =1  #define USB_PAIRED_EP                   0x09            // enpoint 2 in& 2 out paired
  26      =1  #define USB_ITRS_EP_IN                  bmEP2           // itr on in ep2 is used
  27      =1  #define USB_EP_IN_DESC                  0x82
  28      =1  #endif
  29      =1  */
  30      =1  
  31      =1  // MSB=message length + LSB=code identification number
  32      =1  #define USB_MISC_UNUSED                     0x00
  33      =1  #define USB_UNUSED                      0x01
  34      =1  #define USB_TWO_BYTE_SYS_COM            0x22
  35      =1  #define USB_TREE_BYTE_SYS_COM           0x33
  36      =1  #define USB_SYSEX_START_IN              0x34
  37      =1  #define USB_SYSEX_END_SINGLE            0x15
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 29  

  38      =1  #define USB_SYSEX_END_TWO               0x26
  39      =1  #define USB_SYSEX_END_TREE              0x37
  40      =1  
  41      =1  #define USB_NOTE_OFF                    0x38
  42      =1  #define USB_NOTE_ON                     0x39
  43      =1  #define USB_POLY_KEYPRESS                   0x3A
  44      =1  #define USB_CONT_CHANGE                 0x3B
  45      =1  #define USB_PROG_CHANGE                 0x2C
  46      =1  #define USB_CHAN_PRESSURE                   0x2D
  47      =1  #define USB_PITCHBEND                   0x3E
  48      =1  #define USB_SINGLE_BYTE                 0x1F
  49      =1  #endif
  11          #include "serial.h"
   1      =1  #ifndef SERIAL_H                //Header sentry
   2      =1  #define SERIAL_H
   3      =1  
   4      =1  #define Z8_MEM_SIZE                                     65536
   5      =1  #define EZUSB_MEM_SIZE                          8192
   6      =1  
   7      =1  #define XTAL                                            48000000L       // in hertz
   8      =1  #define MIDI_OUT_1_BAUD_RATE            31250L          // in bauds
   9      =1  
  10      =1  #define MIDI_OUT_1_BAUD_RELOAD                  (65536-(XTAL/(32L*MIDI_OUT_1_BAUD_RATE)))       // timer 2
  11      =1  #define SERIAL_TO_Z8_BAUD_RELOAD                ((2*XTAL)/(32*12*BAUD_Z8_EZ))   // timer 1
  12      =1  #define SERIAL_TO_OCD_Z8_BAUD_RELOAD    ((2*XTAL)/(32*12*BAUD_OCD_Z8_EZ))       // timer 1 (ON CHIP DEBUGGER Z8)
  13      =1  
  14      =1  
  15      =1  #define TIMER0_PERIOD                           2 // in milliseconds
  16      =1  #define TIMER0_RELOAD                           (65536-(((XTAL*TIMER0_PERIOD)/(12*1000L))))
  17      =1  
  18      =1  #define SERIAL_TX_BUFF_LENGTH           32 // used as a buffer for MIDI outputs
  19      =1  
  20      =1  enum {WAIT_SOF, FRAME_STATUS_BYTE, WAIT_EOF }; // Frame state from Z8 serial
  21      =1  enum {WAIT_FOR_CORRECT_DATA, IN_SYSEX, SYSEX_RECEIVED, NORMAL, FIFO_FULL }; // MIDI Merger State Byte
  22      =1  enum {CN0, CN1 };        // USB MIDI CABLE NUMBER
  23      =1  enum {SERIAL, USB }; // Bootloader source port
  24      =1  
  25      =1  #define CTRL_REG_Z8_FRAME_LENGHT                0x04 // FF SS VV FE FF SS VV FE
  26      =1  
  27      =1  // jlabs MAWZER RECOGNIZED SYSEXS (RECEIVED BY MAWZER)
  28      =1  
  29      =1  // jlabs MAWZER RECOGNIZED SYSEXS (SENT BY MAWZER)
  30      =1  
  31      =1  
  32      =1  // FUNCTION PROTOTYPES
  33      =1  void Init_Serial_Ports(void);
  34      =1  void Send_To_Midi_Out_Con(BYTE data_to_send);
  35      =1  void Check_MIDI_Buff_Send_To_Z8_Board(Midi_In_Struct *midi_struct, BYTE end_index_local);
  36      =1  void Send_To_Serial_Z8(BYTE data_to_send);
  37      =1  void Send_Single_Framed_byte_To_Z8(/*v1.1 BYTE SYSEX_ID0,*/ BYTE SYSEX_ID2, BYTE byte_to_send);
  38      =1  
  39      =1  #endif // SERIAL_H
  12          #include "itr.h"
   1      =1  #ifndef ITR_H           //Header sentry
   2      =1  #define ITR_H
   3      =1  
   4      =1  // PROTOTYPES
   5      =1  //static 
   6      =1  void Check_Midi_In_From_Con_Data_Received(unsigned char data_received);
   7      =1  //static 
   8      =1  void Check_Serial_From_Z8_Data_Received(unsigned char data_received);
   9      =1  //static 
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 30  

  10      =1  void Check_Realtime_MIDI_Data_Received(unsigned char data_received, Midi_In_Realtime_Struct *midi_struct) 
             -reentrant;
  11      =1  //static 
  12      =1  unsigned char Get_MIDI_Msg_Size(unsigned char status) reentrant;
  13      =1  //static 
  14      =1  void MIDI_In_Add_Buffer(unsigned char data_in, Midi_In_Struct *midi_struct) reentrant;
  15      =1  
  16      =1  #endif
  13          #include "bootloader.h"
   1      =1  #ifndef BOOTLOADER_H            //Header sentry
   2      =1  #define BOOTLOADER_H
   3      =1  
   4      =1  enum { BOOTLOADER_OFF, SEND_IDENTITY_SYSEX, WAIT_EZ_FW_DATA, WAIT_Z8_FW_DATA, TERMINATE_FW_UPGRADE/*, VERI
             -FY_Z8_CRC */};
   5      =1  
   6      =1  // Z8 ENCORE ON CHIP DEBUGGER DEFINITION
   7      =1  #define OCD_FIRST_BYTE                          0x80    // used to autodetect ocd bit rate
   8      =1  //ocd commands
   9      =1  #define OCD_WRITE_PRG_MEM_CMD           0x0A    // 
  10      =1  #define OCD_READ_PRG_MEM_CMD            0x0B    // V1.4
  11      =1  #define OCD_WRITE_CTR_REG_CMD           0x04    // 
  12      =1  #define OCD_WRITE_REG_CMD                       0x08
  13      =1  #define OCD_READ_FLASH_CRC                      0x0E
  14      =1  // ocd datas
  15      =1  #define OCD_FLASH_FIRST_UNLOCK          0x73
  16      =1  #define OCD_FLASH_SECOND_UNLOCK         0x8C
  17      =1  #define OCD_FLASH_MASS_ERASE            0x63
  18      =1  #define OCD_FLASH_CTR_REG_RESET         0x00
  19      =1  #define OCD_CTR_REG_DBGMODE                     0x81
  20      =1  // registers addresses
  21      =1  #define OCD_OPTION_REG_ADD                      0x0000
  22      =1  #define OCD_FLASH_CTR_REG_ADD           0x0FF8
  23      =1  #define OCD_FLASH_FREQ_REG_HIGH_ADD     0x0FFA
  24      =1  #define OCD_FLASH_FREQ_REG_LOW_ADD      0x0FFB
  25      =1  #define OCD_FLASH_SELECT_PAGE           0x0FF9
  26      =1                  
  27      =1  #define OCD_Z8_FLASH_FREQ_REG   (Z8_FREQ / 1000)
  28      =1  
  29      =1  #define I2C_EE_HH_ADDR                  0x01
  30      =1  #define SERIAL_ADDR                             0x50
  31      =1  #define I2C_Addr                                (SERIAL_ADDR | I2C_EE_HH_ADDR)  
  32      =1  #define FW_SYSX_DATA_START              11              // f0 00 20 4f 00 01 ss ll aa aa aa  
  33      =1  
  34      =1  //#define fw_checksum                   sync24_clear_clock_cpt
  35      =1  //#define fw_bl_src                             sync24_clear_cont_cpt
  36      =1  
  37      =1  enum { FW_BL_SRC_UNKNOWN, FW_BL_SRC_MIDI_IN, FW_BL_SRC_USB_IN };
  38      =1  
  39      =1  // BOOTLOADER SYSEX DEFINITION
  40      =1  
  41      =1  
  42      =1  // FUNCTIONS PROTOTYPES
  43      =1  //void SoftReset(void);
  44      =1  void Check_Bootloader(void);
  45      =1  void SendIdentityBootLoader(void);
  46      =1  void SendFwAcknoledge(unsigned char result);
  47      =1  void AssignJlabsSysexHeader(void);
  48      =1  void SendDispatchFwSysex(void);
  49      =1  void WaitNextBootLoaderState(unsigned char awaited_state);
  50      =1  void DecodeFirmwareSysex(Midi_In_Struct *midi_struct);
  51      =1  //void EEPROMWriteByte(WORD addr, BYTE value);
  52      =1  BYTE EEPROMWriteVerify(WORD addr, BYTE length, BYTE xdata *buf); //, BYTE buffer_max_length); //TPM EEPROM
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 31  

             - Write
  53      =1  void WriteSingleRegOCD(WORD address, BYTE value);
  54      =1  void InitFlashFrqAndUnlock(void);
  55      =1  
  56      =1  #endif
  57      =1  
  14          #include "hardware.h"
   1      =1  #ifndef HARDWARE_H              //Header sentry
   2      =1  #define HARDWARE_H
   3      =1  
   4      =1  // DEFINES
   5      =1  #define USB_LED_PERSISTENCY             10      // in multiple of 2ms
   6      =1  
   7      =1  // PROTOTYPING
   8      =1  void Init_Variables(void);
   9      =1  void Init_IOs(void);
  10      =1  void SyncToZ8Board(void);
  11      =1  //void Check_InitialSwitchesState(void);
  12      =1  
  13      =1  #endif
  15          #include "fw.h"
   1      =1  #ifndef FW_H            //Header sentry
   2      =1  #define FW_H
   3      =1  
   4      =1  //-----------------------------------------------------------------------------
   5      =1  // Prototypes
   6      =1  //-----------------------------------------------------------------------------
   7      =1  void SetupCommand(void);
   8      =1  void TD_Init(void);
   9      =1  extern void TD_Poll(void);
  10      =1  BOOL TD_Suspend(void);
  11      =1  BOOL TD_Resume(void);
  12      =1  
  13      =1  BOOL DR_GetDescriptor(void);
  14      =1  BOOL DR_SetConfiguration(void);
  15      =1  BOOL DR_GetConfiguration(void);
  16      =1  BOOL DR_SetInterface(void);
  17      =1  BOOL DR_GetInterface(void);
  18      =1  BOOL DR_GetStatus(void);
  19      =1  BOOL DR_ClearFeature(void);
  20      =1  BOOL DR_SetFeature(void);
  21      =1  BOOL DR_VendorCmnd(void);
  22      =1  
  23      =1  #endif // SERIAL_H
  16          #include "macros.inc"
   1      =1  #ifndef MACROS_INC              //Header sentry
   2      =1  #define MACROS_INC
   3      =1  
   4      =1  /* ************************************** MACROS ***************************** */
   5      =1  
   6      =1  /*
   7      =1  #define MAC_MIDI_In_Inc_Index(index, max_index) {       index++; \
   8      =1                                                          if(index >= max_index)  \
   9      =1                                                             index = 0; }
  10      =1  
  11      =1  #define MAC_MIDI_In_Add_Index(index, added, max_index) { index = index+added; \
  12      =1                                                          if(index >= max_index)  \
  13      =1                                                             index -= max_index; }
  14      =1  */
  15      =1  
  16      =1  #endif
  17      =1  
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 32  

  17          
  18          
  19           // Number of bytes which should be sent
  20          BYTE code usb_midi_bytes_to_send[] = {
  21                  0, // 0: invalid/reserved event
  22                  0, // 1: invalid/reserved event
  23                  2, // 2: two-byte system common messages like MTC, Song Select, etc.
  24                  3, // 3: three-byte system common messages like SPP, etc.
  25                  3, // 4: SysEx starts or continues
  26                  1, // 5: Single-byte system common message or sysex sends with following single byte
  27                  2, // 6: SysEx sends with following two bytes
  28                  3, // 7: SysEx sends with following three bytes
  29                  3, // 8: Note Off
  30                  3, // 9: Note On
  31                  3, // a: Poly-Key Press
  32                  3, // b: Control Change
  33                  2, // c: Program Change
  34                  2, // d: Channel Pressure
  35                  3, // e: PitchBend Change
  36                  1, // f: single byte 
  37          };
  38          
  39          // FROM FW.C
  40          extern volatile BOOL    GotSUD;
  41          extern volatile BOOL    Sleep;                                          // Sleep mode enable flag
  42          extern BOOL                             Rwuen;
  43          
  44          // FROM MAIN.C
  45          extern xdata Midi_In_Struct  MIDI_In_From_Usb;
  46          extern unsigned char bdata CTRL_REGS_7BITS_TO_Z8[CTRL_REG_MAX_FROM_EZ_TO_Z8];
  47          extern bit usb_state_from_ez0_bit;
  48          extern bit usb_enumrated_from_ez0_bit;
  49          extern bit z8_board_fully_updated_from_ez0_bit;
  50          extern bit realtime_source_int_z_ez1_bit;
  51          extern bit realtime_source_ext_z_ez1_bit;
  52          extern idata Midi_In_Realtime_Struct  MIDI_In_Realtime_From_Usb;
  53          extern xdata Midi_In_Struct Serial_In_From_Z8;
  54          
  55          
  56          // FROM BOOTLOADER.C
  57          extern volatile BYTE bootloader_state;
  58          extern BYTE fw_bl_src;  // shared reg
  59          
  60          // FROM ITR.C
  61          extern unsigned char timeout_cpt;
  62          
  63          // ***************************************************************************
  64          // Routine      : Check_If_Usb_Attached()
  65          // Input        : 
  66          // Output       : yes/no
  67          // Process      : also update usb led
  68          // ***************************************************************************
  69          void Check_If_Usb_Attached(void)
  70          {
  71   1              bit must_change_usb_state = FALSE;
  72   1              bit usb_monitor_input = VUSB_PORT_IN & VUSB_PIN;
  73   1      
  74   1              // usb was NOT present
  75   1              if(!usb_state_from_ez0_bit)
  76   1              {
  77   2                      // is the vusb present ?
  78   2                      if(usb_monitor_input)
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 33  

  79   2                      {
  80   3                              // reconnect the device
  81   3                              USBCS &= ~bmDISCON;
  82   3                              // is the 3x enumerated ?
  83   3                              if(usb_enumrated_from_ez0_bit)
  84   3                                      must_change_usb_state = TRUE;   
  85   3                      }
  86   2              }
  87   1              else
  88   1              // the usb was present
  89   1              {
  90   2                      // is the vusb NOT present ?
  91   2                      if(!usb_monitor_input)
  92   2                      {
  93   3                              // disconnect the device
  94   3                              USBCS |= bmDISCON;
  95   3                              // the device is no more enumerated
  96   3                              usb_enumrated_from_ez0_bit = FALSE;
  97   3                              must_change_usb_state = TRUE;   
  98   3                      }
  99   2              }
 100   1      
 101   1              if(must_change_usb_state)
 102   1              {
 103   2                      // V1.5
 104   2      //              USB_LED_PORT_OUT |= USB_LED_PIN;
 105   2      
 106   2                      // send only if z8 ready to receive
 107   2                      if(z8_board_fully_updated_from_ez0_bit)
 108   2                      {
 109   3                              usb_state_from_ez0_bit = !usb_state_from_ez0_bit;
 110   3      
 111   3                              // send only if not in bootloader state
 112   3                              if(!bootloader_state)
 113   3                                      Send_Single_Framed_byte_To_Z8(CTRL_REG_0_7B_FROM_EZ_INDEX, CTRL_REGS_7BITS_TO_Z8[0]);
 114   3                      }
 115   2      
 116   2                      //V1.5 
 117   2      //              USB_LED_PORT_OUT &= ~USB_LED_PIN;
 118   2              }
 119   1      
 120   1      
 121   1      }
 122          
 123          /* ******************************************************************** */
 124          /* Routine: Create_Send_Realtime_USB_Frame_From_MIDI_Buffer                             */
 125          /* Process: Send a single realtime byte MIDI to USB bus                                 */
 126          /* Inputs:      None                                                                                                            */
 127          /* Outputs:     None                                                                                                            */
 128          /* ******************************************************************** */
 129          void Create_Send_Realtime_USB_Frame_From_MIDI_Buffer( unsigned char CN, unsigned char realtime_data)
 130          {
 131   1              // V1.5
 132   1              // if(first_pass) return;
 133   1      
 134   1      //      if((EPIO[USB_IN_ID].cntrl & bmEPBUSY))
 135   1      //              return;
 136   1              
 137   1              // check EP4 FULL(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is full
 138   1          if(EP2468STAT & bmEP4FULL)
 139   1              return;
 140   1      
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 34  

 141   1              // turn on USB led
 142   1      //      USB_LED_PORT_OUT |= USB_LED_PIN;
 143   1      //      timeout_cpt = USB_LED_PERSISTENCY;
 144   1      
 145   1              // Prepare header byte 0
 146   1              EP4FIFOBUF[0] = ((CN << 4) & 0xF0) | (USB_SINGLE_BYTE & 0x0F);          
 147   1              EP4FIFOBUF[1] = realtime_data;
 148   1              EP4FIFOBUF[2] = 0;
 149   1              EP4FIFOBUF[3] = 0;
 150   1      
 151   1              // Now send out to USB
 152   1              // EPIO[USB_IN_ID].bytes = MIDI_USB_FRAME_LENGHT;
 153   1      
 154   1          EP4BCH = 0;  
 155   1          SYNCDELAY;  
 156   1          EP4BCL = MIDI_USB_FRAME_LENGHT;  // arm EP4IN
 157   1          SYNCDELAY;                    
 158   1      
 159   1              // turn off USB led
 160   1      //      USB_LED_PORT_OUT &= ~USB_LED_PIN;
 161   1      }
 162          
 163          #pragma NOAREGS; 
 164          
 165          /* ******************************************************************** */
 166          /* Routine: Check_Usb                                                                                                   */
 167          /* Process:                                                                                                                     */
 168          /* Inputs:      None                                                                                                            */
 169          /* Outputs:     None                                                                                                            */
 170          /* ******************************************************************** */
 171          void Check_Usb(void)
 172          {
 173   1            // Check for pending SETUP
 174   1            if(GotSUD)
 175   1            {
 176   2               SetupCommand();          // Implement setup command
 177   2               GotSUD = FALSE;          // Clear SETUP flag
 178   2            }
 179   1      
 180   1            // check for and handle suspend.
 181   1            // NOTE: Idle mode stops the processor clock.  There are only two
 182   1            // ways out of idle mode, the WAKEUP pin, and detection of the USB
 183   1            // resume state on the USB bus.  The timers will stop and the
 184   1            // processor will not wake up on any other interrupts.
 185   1            if (Sleep)
 186   1            {
 187   2               if(TD_Suspend())
 188   2               { 
 189   3                  Sleep = FALSE;     // Clear the "go to sleep" flag.  Do it here to prevent any race condition 
             -between wakeup and the next sleep.
 190   3                  do
 191   3                  {
 192   4                     EZUSB_Susp();         // Place processor in idle mode.
 193   4                                 //IOD ^= 2;
 194   4                  }
 195   3                  while(!Rwuen && EZUSB_EXTWAKEUP());
 196   3                  // above.  Must continue to go back into suspend if the host has disabled remote wakeup
 197   3                  // *and* the wakeup was caused by the external wakeup pin.
 198   3      
 199   3                  // 8051 activity will resume here due to USB bus or Wakeup# pin activity.
 200   3                  EZUSB_Resume();   // If source is the Wakeup# pin, signal the host to Resume.      
 201   3                  TD_Resume();
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 35  

 202   3               }   
 203   2            }
 204   1      }
 205          
 206          /* ******************************************************************** */
 207          /* Routine: Create_Send_USB_Frame_From_MIDI_Buffer                                              */
 208          /* Process: Treat each MIDI messages from MIDI buffer, encapsulate MIDI */
 209          /*                      into USB frames                                                                                         */
 210          /* Inputs:      None                                                                                                            */
 211          /* Outputs:     None                                                                                                            */
 212          /* ******************************************************************** */
 213          void Create_Send_USB_Frame_From_MIDI_Buffer( BYTE CN, Midi_In_Struct *midi_struct, BYTE end_index_local)
 214          {
 215   1              unsigned char /* buffer_length,*/ cin, start_index_local, end_sysex_index, mess_lenght, i;
 216   1              unsigned char usb_frame[MIDI_USB_FRAME_LENGHT];
 217   1              unsigned char status;
 218   1              bit usb_out_in_sysex; //, must_skip_header_frame;
 219   1              BYTE usb_buffer_index;
 220   1              
 221   1              if(!usb_state_from_ez0_bit)
 222   1                      return;
 223   1      
 224   1              // V1.5
 225   1              // if(first_pass) return;
 226   1      
 227   1              usb_out_in_sysex        = FALSE;
 228   1              usb_buffer_index        = 0;
 229   1              start_index_local       = midi_struct->start_index;
 230   1      
 231   1              // Treat all bytes to send
 232   1              while(start_index_local != end_index_local)
 233   1              {
 234   2                      // turn on USB led
 235   2      //              USB_LED_PORT_OUT |= USB_LED_PIN;
 236   2      //              timeout_cpt = USB_LED_PERSISTENCY;
 237   2              
 238   2      //              must_skip_header_frame = FALSE;
 239   2      
 240   2                      // wait for the usb buffer to become ready
 241   2                      //if(!(EPIO[USB_IN_ID].cntrl & bmEPBUSY))
 242   2                      {
 243   3                              // Prepare header byte 0
 244   3                              usb_frame[0] = (CN << 4); // & 0xF0;            
 245   3              
 246   3                              // ignore frame header FF UU LL if NOT in sysex or if bootloading and sending from serial_in_from_z8
 247   3                              if( (!bootloader_state) && (!usb_out_in_sysex) && (midi_struct == &Serial_In_From_Z8) )
 248   3                              {
 249   4                              //      must_skip_header_frame = TRUE;
 250   4                                      // V1.4 in the case of a single midi string contains multiple MIDI events, the different midi
 251   4                                      // events are not seperated by FF UU LL : then do not skip these bytes since not present
 252   4                                      // the idea is to skip only if these bytes are found in the string
 253   4                                      if(midi_struct->buffer[start_index_local] == SOF_TO_EZ)
 254   4                                              start_index_local = (start_index_local + 3) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);       
 255   4                              }
 256   3              
 257   3                              // Initialize USB frame buffer to zero to avoid eventual zero padding
 258   3                              usb_frame[1] = 0;
 259   3                              usb_frame[2] = 0;
 260   3                              usb_frame[3] = 0;
 261   3              
 262   3                              // Check if already in sysex ?
 263   3                              if(usb_out_in_sysex)
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 36  

 264   3                              {
 265   4                                      // We are in sysex, check remaining sysex bytes to send
 266   4                                      usb_out_in_sysex = FALSE;
 267   4                                      // sysex_length contains remaining bytes of the long sysex to send
 268   4                                      // 1 byte remaining in SYSEX : it is F7
 269   4                                      if(mess_lenght == 1)
 270   4                                      {
 271   5                                              cin                      = USB_SYSEX_END_SINGLE & 0x0F;
 272   5                                              usb_frame[1]     = MIDI_EOX;
 273   5                                              start_index_local = (start_index_local + 1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 274   5                                      }
 275   4                                      else
 276   4                                      // sysex end with 2 or 3 bytes or into unfinished sysex
 277   4                                      {
 278   5                                              usb_frame[1] = midi_struct->buffer[start_index_local];
 279   5                                              
 280   5                                              // 2 Bytes remaining in SYSEX : it is DD F7
 281   5                                              if(mess_lenght == 2)
 282   5                                              {
 283   6                                                      cin                      = USB_SYSEX_END_TWO & 0x0F;
 284   6                                                      usb_frame[2]     = MIDI_EOX;
 285   6                                                      start_index_local = (start_index_local + 2) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 286   6                                              }
 287   5                                              else 
 288   5                                              // sysex end with 3 bytes or into unfinished sysex
 289   5                                              {                                       
 290   6                                                      usb_frame[2] = midi_struct->buffer[(start_index_local+1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1)];
 291   6                                                      usb_frame[3] = midi_struct->buffer[(start_index_local+2) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1)];
 292   6                                                      start_index_local = (start_index_local + 3) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 293   6                      
 294   6                                                      if(mess_lenght==3)
 295   6                                                      {
 296   7                                                              cin = USB_SYSEX_END_TREE & 0x0F;
 297   7                                                      }
 298   6                                                      else // More than 3 remaining bytes were in sysex
 299   6                                                  {
 300   7                                                              cin = USB_SYSEX_START_IN & 0x0F;
 301   7                                                              usb_out_in_sysex = TRUE;
 302   7                                                      }
 303   6                                                      
 304   6                                                      mess_lenght -= 3; // 3 bytes of the long sysex have been sent
 305   6                                              }               
 306   5                                      }
 307   4                              } // end we already were in sysex
 308   3                              else
 309   3                              // Is it a START of SYSEX ?
 310   3                              if(midi_struct->buffer[start_index_local] == MIDI_SOX)
 311   3                              {
 312   4                                      usb_out_in_sysex = TRUE;
 313   4                                      usb_frame[1]     = MIDI_SOX;
 314   4                                      start_index_local = (start_index_local + 1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 315   4              
 316   4                                      // Search for end sysex index position F7
 317   4                                      end_sysex_index = start_index_local;
 318   4                                      mess_lenght    = 1;
 319   4                                      while( (midi_struct->buffer[end_sysex_index] != MIDI_EOX) && (end_sysex_index != end_index_local))
 320   4                                      {
 321   5                                                      if(++mess_lenght < MIDI_USB_FRAME_LENGHT)
 322   5                                                      {
 323   6                                                              usb_frame[mess_lenght] = midi_struct->buffer[end_sysex_index];
 324   6                                                              start_index_local = (start_index_local + 1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 325   6                                                      }
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 37  

 326   5                                                      end_sysex_index = (end_sysex_index + 1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 327   5                                      }
 328   4                                      
 329   4                                      mess_lenght++;
 330   4      
 331   4                                      // Now end_sysex_index should contains position of EOX F7
 332   4                                      // Check if special case : 2 bytes sysex ?
 333   4                                      if(mess_lenght == 2)
 334   4                                      {
 335   5                                              cin                      = USB_SYSEX_END_TWO & 0x0F;
 336   5                                              usb_frame[2]     = MIDI_EOX;
 337   5                                      }
 338   4                                      else
 339   4                                      if(mess_lenght==3)
 340   4                                      {
 341   5                                              cin                      = USB_SYSEX_END_TREE & 0x0F;
 342   5                                              usb_frame[3]     = MIDI_EOX;
 343   5                                      }
 344   4                                      else
 345   4                                      {
 346   5                                              cin                      = USB_SYSEX_START_IN & 0x0F;
 347   5                                              usb_out_in_sysex = TRUE;
 348   5                                              mess_lenght     -= 3; // 3 bytes of the long sysex have been sent
 349   5                                      }
 350   4                              } // end start_index is START_OF_SYSEX
 351   3                              else
 352   3                              // Not a start of sysex, Not in sysex, not an end of sysex
 353   3                              {
 354   4                                      status = midi_struct->buffer[start_index_local];
 355   4                                      // get midi mess lenght from status
 356   4                                      EA = 0;
 357   4                                      mess_lenght = Get_MIDI_Msg_Size(status) + 1;
 358   4                                      EA = 1;
 359   4                                      if( (status >= MIDI_NOTE_OFF) && (status < MIDI_SOX ))
 360   4                                              cin = status >> 4;
 361   4                                      else
 362   4                                              cin = mess_lenght;
 363   4      
 364   4                                      for(i=0; i < mess_lenght; i++)
 365   4                                      {
 366   5                                              usb_frame[i+1] = midi_struct->buffer[start_index_local];
 367   5                                              start_index_local = (start_index_local + 1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);
 368   5                                      }
 369   4                              }
 370   3              
 371   3                              // add cin to usb first byte
 372   3                              usb_frame[0] |= cin; 
 373   3              
 374   3                              // assign local usb buffer to real usb buffer
 375   3                              for(i=0; i < MIDI_USB_FRAME_LENGHT; i++)
 376   3                                       // USB_IN_BUFFER[i] = usb_frame[i];
 377   3                                      EP4FIFOBUF[i + usb_buffer_index] = usb_frame[i];                                
 378   3              
 379   3                              usb_buffer_index += MIDI_USB_FRAME_LENGHT;
 380   3      
 381   3                              Check_Usb();
 382   3      
 383   3                              // buffer full ? send and reset index
 384   3                              if(usb_buffer_index >= USB_EP_BUFFER_LENGHT)
 385   3                              {
 386   4      //                              if(!(EPIO[USB_IN_ID].cntrl & bmEPBUSY))
 387   4                                      // check EP4 FULL(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is full
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 38  

 388   4                                  if(!(EP2468STAT & bmEP4FULL))
 389   4                                      {
 390   5                                      // send buffer to usb out
 391   5                                              // EPIO[USB_IN_ID].bytes = usb_buffer_index;
 392   5                                              EP4BCH = 0;  
 393   5                                              SYNCDELAY;  
 394   5                                              EP4BCL = usb_buffer_index;  // arm EP4IN
 395   5                                              SYNCDELAY;                    
 396   5                                      }
 397   4                                      usb_buffer_index = 0;
 398   4                              }
 399   3      
 400   3                              // ignore frame header EOF (FE)
 401   3                              if( (!bootloader_state) && (!usb_out_in_sysex) && (midi_struct == &Serial_In_From_Z8))
 402   3                              //if(must_skip_header_frame)
 403   3                                      // V1.4 in the case of a single midi string contains multiple MIDI events, the different midi
 404   3                                      // events are not seperated by FF UU LL : then do not skip these bytes since not present
 405   3                                      // the idea is to skip only if these bytes are found in the string
 406   3                                      if(midi_struct->buffer[start_index_local] == EOF_TO_EZ)
 407   3                                              start_index_local = (start_index_local + 1) & (MIDI_IN_FROM_CON_BUFF_LENGHT - 1);       
 408   3      
 409   3                      } // en endpoint was not busy
 410   2      
 411   2                      // turn off USB led
 412   2                      //USB_LED_PORT_OUT &= ~USB_LED_PIN; 
 413   2      
 414   2              } // end while
 415   1      
 416   1              // remaining bytes in the buffer ?
 417   1              if(usb_buffer_index)
 418   1              {
 419   2      //              if(!(EPIO[USB_IN_ID].cntrl & bmEPBUSY))
 420   2                              // send buffer to usb out
 421   2      //                      EPIO[USB_IN_ID].bytes = usb_buffer_index;
 422   2                  if(!(EP2468STAT & bmEP4FULL))
 423   2                      {
 424   3                              // send buffer to usb out
 425   3                              // EPIO[USB_IN_ID].bytes = usb_buffer_index;
 426   3                              EP4BCH = 0;  
 427   3                              SYNCDELAY;  
 428   3                              EP4BCL = usb_buffer_index;  // arm EP4IN
 429   3                              SYNCDELAY;                    
 430   3                      }
 431   2              }       
 432   1      }
 433          
 434          // ******************************************************************** 
 435          // Routine: ISR_Ep2out ISR                                                                                              
 436          // Process:                                                                                                                     
 437          // Inputs:      None                                                                                                            
 438          // Outputs:     None                                                                                                            
 439          // ******************************************************************** 
 440          void Ep2out_Function(void)
 441          { 
 442   1              unsigned char cin, frame, index, nb_bytes;
 443   1              WORD n;
 444   1      
 445   1              // treat incoming data only if bootloader is off or src bootloader is usb in 
 446   1              // since the bl uses midi _in buffer for communicating with the host via usb
 447   1              if(usb_state_from_ez0_bit)
 448   1              if(z8_board_fully_updated_from_ez0_bit)
 449   1              if(fw_bl_src != FW_BL_SRC_MIDI_IN)
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 39  

 450   1              {
 451   2                      // Is there something in the OUT2BUF buffer? Store it to usb buffer
 452   2                      // if(  !(EPIO[OUT2BUF_ID].cntrl & bmEPBUSY) && (n = EPIO[OUT2BUF_ID].bytes) )
 453   2                      // check EP2 EMPTY(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is empty
 454   2                      if(!(EP2468STAT & bmEP2EMPTY))
 455   2                      {
 456   3                              // Get data size
 457   3                              n = (EP2BCH << 8) + EP2BCL;
 458   3      
 459   3                              // turn on USB led
 460   3      //                      USB_LED_PORT_OUT |= USB_LED_PIN;
 461   3      //                      timeout_cpt = USB_LED_PERSISTENCY;
 462   3      
 463   3                              // frame is the base address of each new midi frame (0, 4, ..)
 464   3                              //frame=0;
 465   3                              for(frame=0; frame < n; frame=frame + MIDI_USB_FRAME_LENGHT)
 466   3                              //while(frame < n)
 467   3                              {
 468   4                              // Get CIN
 469   4                              cin = EP2FIFOBUF[frame] & 0x0F;
 470   4      
 471   4                                      // consider only data In on cable nb 0
 472   4                                      if( (EP2FIFOBUF[frame] >> 4) == CN0)
 473   4                                      {
 474   5                                      // Check if realtime, update realtime register and exit
 475   5                                      if(cin == (USB_SINGLE_BYTE & 0x0F))
 476   5                                              {
 477   6                                                      // check incoming realtime data received if realtime source is USB IN
 478   6                                                      if(realtime_source_ext_z_ez1_bit)
 479   6                                                              {
 480   7                                                                      EA = 0;
 481   7                                                                      Check_Realtime_MIDI_Data_Received(EP2FIFOBUF[frame+1], &MIDI_In_Realtime_From_Usb);
 482   7                                                                      EA = 1;
 483   7                                                              }
 484   6                                              }
 485   5                                      else // Non realtime message
 486   5                                      {
 487   6                                              // Get message length
 488   6                                              nb_bytes  = usb_midi_bytes_to_send[cin];
 489   6                                                      // add all other message bytes
 490   6                                                      
 491   6                                                      //DBG
 492   6                                                      //Send_To_Midi_Out_Con(0xF0);
 493   6      
 494   6                                              for(index=0; index < nb_bytes ; index++)
 495   6                                                      {
 496   7                                                              //DBG
 497   7                                                              //Send_To_Midi_Out_Con(OUT2BUF[index+frame+1] >> 4);
 498   7                                                              //Send_To_Midi_Out_Con(OUT2BUF[index+frame+1] & 0x0F);
 499   7                                              EA = 0;
 500   7                                                              // add data to midi_in_from_usb_buff
 501   7                                              MIDI_In_Add_Buffer(EP2FIFOBUF[index+frame+1], &MIDI_In_From_Usb);
 502   7                                                              EA = 1;
 503   7                                                              // DBG  Send_To_Midi_Out_Con(EP2FIFOBUF[index+frame+1]);
 504   7                                                      }
 505   6      
 506   6                                              // Check if message is complete OR if we are in a sysex
 507   6                                                      if(nb_bytes)
 508   6                                                              if(cin != (USB_SYSEX_START_IN & 0x0F))
 509   6                                                              // Set the end_index pointer to enable transmission
 510   6                                                              MIDI_In_From_Usb.end_index = MIDI_In_From_Usb.current_index;
 511   6                                              
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 40  

 512   6                                              } // end non realtime
 513   5                                      } // end data was on CN0
 514   4                                      
 515   4                                      //frame += MIDI_USB_FRAME_LENGHT;
 516   4                              
 517   4                      } // enfor frame
 518   3      
 519   3                              // Arm the OUT so it can receive the next packet
 520   3                              // EPIO[OUT2BUF_ID].bytes = 0;
 521   3                      EP2BCL = 0x80;          // re(arm) EP2OUT
 522   3              //          SYNCDELAY;                    
 523   3      
 524   3                              // turn off USB led
 525   3                              //USB_LED_PORT_OUT &= ~USB_LED_PIN;     
 526   3                      
 527   3                      } // end if usb buffer contains data
 528   2              } // end bootloader source buffer is not midi in connector
 529   1      }
 530          
 531          #pragma AREGS
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 41  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com0050 (BEGIN)
0000         L?0081:
0000         L?0082:
0000 AB00        R     MOV     R3,midi_struct
0002 E500        R     MOV     A,midi_struct+02H
0004 2405              ADD     A,#05H
0006 F9                MOV     R1,A
0007 E4                CLR     A
0008 3500        R     ADDC    A,midi_struct+01H
000A FA                MOV     R2,A
000B 7E00              MOV     R6,#00H
000D E9                MOV     A,R1
000E 2500        R     ADD     A,start_index_local
0010         L?0083:
0010 F9                MOV     R1,A
0011 EE                MOV     A,R6
0012 3A                ADDC    A,R2
0013 FA                MOV     R2,A
0014 020000      E     LJMP    ?C?CLDPTR
0017         L?0084:
0017         L?0085:
0017 AB00        R     MOV     R3,midi_struct
0019         L?0086:
0019 E500        R     MOV     A,midi_struct+02H
001B 2405              ADD     A,#05H
001D F9                MOV     R1,A
001E E4                CLR     A
001F 3500        R     ADDC    A,midi_struct+01H
0021 FA                MOV     R2,A
0022 22                RET     
0023         L?0087:
0023 C6                XCH     A,@R0
0024         L?0088:
0024 E500        R     MOV     A,start_index_local
0026 04                INC     A
0027 547F              ANL     A,#07FH
0029 F500        R     MOV     start_index_local,A
002B 22                RET     
002C         L?0089:
002C 7400        E     MOV     A,#LOW EP2FIFOBUF
002E 2500        R     ADD     A,frame
0030 F582              MOV     DPL,A
0032 E4                CLR     A
0033 3400        E     ADDC    A,#HIGH EP2FIFOBUF
0035 F583              MOV     DPH,A
0037 E0                MOVX    A,@DPTR
0038 22                RET     
0039         L?0090:
0039 E500        R     MOV     A,midi_struct
003B 850083      R     MOV     DPH,midi_struct+01H
003E 850082      R     MOV     DPL,midi_struct+02H
0041 6401              XRL     A,#01H
0043 22                RET     
             ; FUNCTION Com0050 (END)

             ; FUNCTION Check_If_Usb_Attached (BEGIN)
                                           ; SOURCE LINE # 69
                                           ; SOURCE LINE # 70
                                           ; SOURCE LINE # 71
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 42  

0000 C200        R     CLR     must_change_usb_state
                                           ; SOURCE LINE # 72
0002 E5B1              MOV     A,IOE
0004 A2E2              MOV     C,ACC.2
0006 9200        R     MOV     usb_monitor_input,C
                                           ; SOURCE LINE # 75
0008 200011      E     JB      usb_state_from_ez0_bit,?C0001
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 78
000B 30001C      R     JNB     usb_monitor_input,?C0004
                                           ; SOURCE LINE # 79
                                           ; SOURCE LINE # 81
000E 900000      E     MOV     DPTR,#USBCS
0011 E0                MOVX    A,@DPTR
0012 54F7              ANL     A,#0F7H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0015 300012      E     JNB     usb_enumrated_from_ez0_bit,?C0004
                                           ; SOURCE LINE # 84
0018 D200        R     SETB    must_change_usb_state
                                           ; SOURCE LINE # 85
                                           ; SOURCE LINE # 86
001A 800E              SJMP    ?C0004
001C         ?C0001:
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 91
001C 20000B      R     JB      usb_monitor_input,?C0004
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 94
001F 900000      E     MOV     DPTR,#USBCS
0022 E0                MOVX    A,@DPTR
0023 4408              ORL     A,#08H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 96
0026 C200        E     CLR     usb_enumrated_from_ez0_bit
                                           ; SOURCE LINE # 97
0028 D200        R     SETB    must_change_usb_state
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
002A         ?C0004:
                                           ; SOURCE LINE # 101
002A 300010      R     JNB     must_change_usb_state,?C0009
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 107
002D 30000D      E     JNB     z8_board_fully_updated_from_ez0_bit,?C0009
                                           ; SOURCE LINE # 108
                                           ; SOURCE LINE # 109
0030 B200        E     CPL     usb_state_from_ez0_bit
                                           ; SOURCE LINE # 112
0032 E500        E     MOV     A,bootloader_state
0034 7007              JNZ     ?C0009
                                           ; SOURCE LINE # 113
0036 AD00        E     MOV     R5,CTRL_REGS_7BITS_TO_Z8
0038 7F08              MOV     R7,#08H
003A 120000      E     LCALL   _Send_Single_Framed_byte_To_Z8
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 121
003D         ?C0009:
003D 22                RET     
             ; FUNCTION Check_If_Usb_Attached (END)

C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 43  

             ; FUNCTION _Create_Send_Realtime_USB_Frame_From_MIDI_Buffer (BEGIN)
                                           ; SOURCE LINE # 129
;---- Variable 'realtime_data' assigned to Register 'R5' ----
;---- Variable 'CN' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 138
0000 E5AA              MOV     A,EP2468STAT
0002 20E322            JB      ACC.3,?C0011
0005         ?C0010:
                                           ; SOURCE LINE # 146
0005 EF                MOV     A,R7
0006 C4                SWAP    A
0007 54F0              ANL     A,#0F0H
0009 440F              ORL     A,#0FH
000B 900000      E     MOV     DPTR,#EP4FIFOBUF
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 147
000F A3                INC     DPTR
0010 ED                MOV     A,R5
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 148
0012 E4                CLR     A
0013 A3                INC     DPTR
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 149
0015 A3                INC     DPTR
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
0017 900000      E     MOV     DPTR,#EP4BCH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
001B 00                NOP     
001C 00                NOP     
001D 00                NOP     
                                           ; SOURCE LINE # 156
001E 900000      E     MOV     DPTR,#EP4BCL
0021 7404              MOV     A,#04H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 157
0024 00                NOP     
0025 00                NOP     
0026 00                NOP     
                                           ; SOURCE LINE # 161
0027         ?C0011:
0027 22                RET     
             ; FUNCTION _Create_Send_Realtime_USB_Frame_From_MIDI_Buffer (END)

             ; FUNCTION Check_Usb (BEGIN)
                                           ; SOURCE LINE # 171
                                           ; SOURCE LINE # 172
                                           ; SOURCE LINE # 174
0000 300005      E     JNB     GotSUD,?C0012
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 176
0003 120000      E     LCALL   SetupCommand
                                           ; SOURCE LINE # 177
0006 C200        E     CLR     GotSUD
                                           ; SOURCE LINE # 178
0008         ?C0012:
                                           ; SOURCE LINE # 185
0008 300029      E     JNB     Sleep,?C0021
                                           ; SOURCE LINE # 186
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 44  

                                           ; SOURCE LINE # 187
000B 120000      E     LCALL   TD_Suspend
000E 5024              JNC     ?C0021
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
0010 C200        E     CLR     Sleep
0012         ?C0017:
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
0012 120000      E     LCALL   EZUSB_Susp
                                           ; SOURCE LINE # 194
                                           ; SOURCE LINE # 195
0015 200016      E     JB      Rwuen,?C0016
0018 900000      E     MOV     DPTR,#WAKEUPCS
001B E0                MOVX    A,@DPTR
001C 30E704            JNB     ACC.7,?C0019
001F E0                MOVX    A,@DPTR
0020 20E1EF            JB      ACC.1,?C0017
0023         ?C0019:
0023 900000      E     MOV     DPTR,#WAKEUPCS
0026 E0                MOVX    A,@DPTR
0027 30E604            JNB     ACC.6,?C0016
002A E0                MOVX    A,@DPTR
002B 20E0E4            JB      ACC.0,?C0017
002E         ?C0016:
                                           ; SOURCE LINE # 200
002E 120000      E     LCALL   EZUSB_Resume
                                           ; SOURCE LINE # 201
0031 120000      E     LCALL   TD_Resume
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
0034         ?C0021:
0034 22                RET     
             ; FUNCTION Check_Usb (END)

             ; FUNCTION _Create_Send_USB_Frame_From_MIDI_Buffer (BEGIN)
                                           ; SOURCE LINE # 213
0000 8F00        R     MOV     CN,R7
0002 8B00        R     MOV     midi_struct,R3
0004 8A00        R     MOV     midi_struct+01H,R2
0006 8900        R     MOV     midi_struct+02H,R1
                                           ; SOURCE LINE # 214
                                           ; SOURCE LINE # 221
0008 200003      E     JB      usb_state_from_ez0_bit,$ + 6H
000B 020000      R     LJMP    ?C0023
000E         ?C0022:
                                           ; SOURCE LINE # 227
000E C200        R     CLR     usb_out_in_sysex
                                           ; SOURCE LINE # 228
0010 E4                CLR     A
0011 F500        R     MOV     usb_buffer_index,A
                                           ; SOURCE LINE # 229
0013 AB00        R     MOV     R3,midi_struct
0015 AA00        R     MOV     R2,midi_struct+01H
0017 A900        R     MOV     R1,midi_struct+02H
0019 120000      E     LCALL   ?C?CLDPTR
001C F500        R     MOV     start_index_local,A
001E         ?C0024:
                                           ; SOURCE LINE # 232
001E E500        R     MOV     A,start_index_local
0020 6500        R     XRL     A,end_index_local
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 45  

0022 7003              JNZ     $ + 5H
0024 020000      R     LJMP    ?C0025
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 242
                                           ; SOURCE LINE # 244
0027 E500        R     MOV     A,CN
0029 C4                SWAP    A
002A 54F0              ANL     A,#0F0H
002C F500        R     MOV     usb_frame,A
                                           ; SOURCE LINE # 247
002E E500        E     MOV     A,bootloader_state
0030 7028              JNZ     ?C0026
0032 200025      R     JB      usb_out_in_sysex,?C0026
0035 7B01              MOV     R3,#01H
0037 7A00        E     MOV     R2,#HIGH Serial_In_From_Z8
0039 7900        E     MOV     R1,#LOW Serial_In_From_Z8
003B 120000      R     LCALL   L?0090
003E 700A              JNZ     ?C0076
0040 7400        E     MOV     A,#LOW Serial_In_From_Z8
0042 6582              XRL     A,DPL
0044 7004              JNZ     ?C0076
0046 7400        E     MOV     A,#HIGH Serial_In_From_Z8
0048 6583              XRL     A,DPH
004A         ?C0076:
004A 700E              JNZ     ?C0026
                                           ; SOURCE LINE # 248
                                           ; SOURCE LINE # 253
004C 120000      R     LCALL   L?0081
004F B4FF08            CJNE    A,#0FFH,?C0026
                                           ; SOURCE LINE # 254
0052 E500        R     MOV     A,start_index_local
0054 2403              ADD     A,#03H
0056 547F              ANL     A,#07FH
0058 F500        R     MOV     start_index_local,A
                                           ; SOURCE LINE # 255
005A         ?C0026:
                                           ; SOURCE LINE # 258
005A E4                CLR     A
005B F500        R     MOV     usb_frame+01H,A
                                           ; SOURCE LINE # 259
005D F500        R     MOV     usb_frame+02H,A
                                           ; SOURCE LINE # 260
005F F500        R     MOV     usb_frame+03H,A
                                           ; SOURCE LINE # 263
0061 300079      R     JNB     usb_out_in_sysex,?C0028
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 266
0064 C200        R     CLR     usb_out_in_sysex
                                           ; SOURCE LINE # 269
0066 E500        R     MOV     A,mess_lenght
0068 B4010B            CJNE    A,#01H,?C0029
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 271
006B 750005      R     MOV     cin,#05H
                                           ; SOURCE LINE # 272
006E 7500F7      R     MOV     usb_frame+01H,#0F7H
                                           ; SOURCE LINE # 273
0071 E500        R     MOV     A,start_index_local
0073 04                INC     A
                                           ; SOURCE LINE # 274
0074 801D              SJMP    ?C0078
0076         ?C0029:
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 46  

                                           ; SOURCE LINE # 277
                                           ; SOURCE LINE # 278
0076 120000      R     LCALL   L?0084
0079 AF00        R     MOV     R7,start_index_local
007B 7E00              MOV     R6,#00H
007D E9                MOV     A,R1
007E 2F                ADD     A,R7
007F 120000      R     LCALL   L?0083
0082 F500        R     MOV     usb_frame+01H,A
                                           ; SOURCE LINE # 281
0084 E500        R     MOV     A,mess_lenght
0086 B40211            CJNE    A,#02H,?C0031
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 283
0089 750006      R     MOV     cin,#06H
                                           ; SOURCE LINE # 284
008C 7500F7      R     MOV     usb_frame+02H,#0F7H
                                           ; SOURCE LINE # 285
008F E500        R     MOV     A,start_index_local
0091 2402              ADD     A,#02H
0093         ?C0078:
0093 547F              ANL     A,#07FH
0095 F500        R     MOV     start_index_local,A
                                           ; SOURCE LINE # 286
0097 020000      R     LJMP    ?C0035
009A         ?C0031:
                                           ; SOURCE LINE # 289
                                           ; SOURCE LINE # 290
009A 120000      R     LCALL   L?0084
009D EF                MOV     A,R7
009E 2401              ADD     A,#01H
00A0 FD                MOV     R5,A
00A1 7C00              MOV     R4,#00H
00A3 ED                MOV     A,R5
00A4 547F              ANL     A,#07FH
00A6 29                ADD     A,R1
00A7 F9                MOV     R1,A
00A8 EC                MOV     A,R4
00A9 3A                ADDC    A,R2
00AA FA                MOV     R2,A
00AB 120000      E     LCALL   ?C?CLDPTR
00AE F500        R     MOV     usb_frame+02H,A
                                           ; SOURCE LINE # 291
00B0 120000      R     LCALL   L?0086
00B3 EF                MOV     A,R7
00B4 2402              ADD     A,#02H
00B6 FF                MOV     R7,A
00B7 7E00              MOV     R6,#00H
00B9 EF                MOV     A,R7
00BA 547F              ANL     A,#07FH
00BC 29                ADD     A,R1
00BD 120000      R     LCALL   L?0083
00C0 F500        R     MOV     usb_frame+03H,A
                                           ; SOURCE LINE # 292
00C2 E500        R     MOV     A,start_index_local
00C4 2403              ADD     A,#03H
00C6 547F              ANL     A,#07FH
00C8 F500        R     MOV     start_index_local,A
                                           ; SOURCE LINE # 294
00CA E500        R     MOV     A,mess_lenght
00CC B40306            CJNE    A,#03H,?C0033
                                           ; SOURCE LINE # 295
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 47  

                                           ; SOURCE LINE # 296
00CF 750007      R     MOV     cin,#07H
                                           ; SOURCE LINE # 297
00D2 020000      R     LJMP    ?C0079
00D5         ?C0033:
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
00D5 750004      R     MOV     cin,#04H
                                           ; SOURCE LINE # 301
00D8 D200        R     SETB    usb_out_in_sysex
                                           ; SOURCE LINE # 302
00DA         ?C0034:
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 307
00DA 020000      R     LJMP    ?C0079
00DD         ?C0028:
                                           ; SOURCE LINE # 310
00DD 120000      R     LCALL   L?0081
00E0 64F0              XRL     A,#0F0H
00E2 7069              JNZ     ?C0036
                                           ; SOURCE LINE # 311
                                           ; SOURCE LINE # 312
00E4 D200        R     SETB    usb_out_in_sysex
                                           ; SOURCE LINE # 313
00E6 7500F0      R     MOV     usb_frame+01H,#0F0H
                                           ; SOURCE LINE # 314
00E9 120000      R     LCALL   L?0088
                                           ; SOURCE LINE # 317
;---- Variable 'end_sysex_index' assigned to Register 'R7' ----
00EC FF                MOV     R7,A
                                           ; SOURCE LINE # 318
00ED 750001      R     MOV     mess_lenght,#01H
00F0         ?C0037:
                                           ; SOURCE LINE # 319
00F0 120000      R     LCALL   L?0085
00F3 EF                MOV     A,R7
00F4 7C00              MOV     R4,#00H
00F6 29                ADD     A,R1
00F7 F9                MOV     R1,A
00F8 EC                MOV     A,R4
00F9 3A                ADDC    A,R2
00FA FA                MOV     R2,A
00FB 120000      E     LCALL   ?C?CLDPTR
00FE FE                MOV     R6,A
00FF 64F7              XRL     A,#0F7H
0101 601F              JZ      ?C0038
0103 EF                MOV     A,R7
0104 6500        R     XRL     A,end_index_local
0106 601A              JZ      ?C0038
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
0108 0500        R     INC     mess_lenght
010A E500        R     MOV     A,mess_lenght
010C C3                CLR     C
010D 9404              SUBB    A,#04H
010F 500A              JNC     ?C0039
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 323
0111 7400        R     MOV     A,#LOW usb_frame
0113 2500        R     ADD     A,mess_lenght
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 48  

0115 F8                MOV     R0,A
0116 C6                XCH     A,@R0
0117 EE                MOV     A,R6
                                           ; SOURCE LINE # 324
0118 120000      R     LCALL   L?0087
                                           ; SOURCE LINE # 325
011B         ?C0039:
                                           ; SOURCE LINE # 326
011B EF                MOV     A,R7
011C 04                INC     A
011D 547F              ANL     A,#07FH
011F FF                MOV     R7,A
                                           ; SOURCE LINE # 327
0120 80CE              SJMP    ?C0037
0122         ?C0038:
                                           ; SOURCE LINE # 329
0122 0500        R     INC     mess_lenght
                                           ; SOURCE LINE # 333
0124 E500        R     MOV     A,mess_lenght
0126 B40209            CJNE    A,#02H,?C0040
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
0129 750006      R     MOV     cin,#06H
                                           ; SOURCE LINE # 336
012C 7500F7      R     MOV     usb_frame+02H,#0F7H
                                           ; SOURCE LINE # 337
012F 020000      R     LJMP    ?C0035
0132         ?C0040:
                                           ; SOURCE LINE # 339
0132 E500        R     MOV     A,mess_lenght
0134 B40309            CJNE    A,#03H,?C0042
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
0137 750007      R     MOV     cin,#07H
                                           ; SOURCE LINE # 342
013A 7500F7      R     MOV     usb_frame+03H,#0F7H
                                           ; SOURCE LINE # 343
013D 020000      R     LJMP    ?C0035
0140         ?C0042:
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
0140 750004      R     MOV     cin,#04H
                                           ; SOURCE LINE # 347
0143 D200        R     SETB    usb_out_in_sysex
                                           ; SOURCE LINE # 348
0145         ?C0079:
0145 74FD              MOV     A,#0FDH
0147 2500        R     ADD     A,mess_lenght
0149 F500        R     MOV     mess_lenght,A
                                           ; SOURCE LINE # 349
                                           ; SOURCE LINE # 350
014B 8046              SJMP    ?C0035
014D         ?C0036:
                                           ; SOURCE LINE # 353
                                           ; SOURCE LINE # 354
014D 120000      R     LCALL   L?0082
0150 F500        R     MOV     status,A
                                           ; SOURCE LINE # 356
0152 C2AF              CLR     EA
                                           ; SOURCE LINE # 357
0154 FF                MOV     R7,A
0155 120000      E     LCALL   _?Get_MIDI_Msg_Size
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 49  

0158 EF                MOV     A,R7
0159 04                INC     A
015A F500        R     MOV     mess_lenght,A
                                           ; SOURCE LINE # 358
015C D2AF              SETB    EA
                                           ; SOURCE LINE # 359
015E E500        R     MOV     A,status
0160 C3                CLR     C
0161 9480              SUBB    A,#080H
0163 400F              JC      ?C0045
0165 E500        R     MOV     A,status
0167 94F0              SUBB    A,#0F0H
0169 5009              JNC     ?C0045
                                           ; SOURCE LINE # 360
016B E500        R     MOV     A,status
016D C4                SWAP    A
016E 540F              ANL     A,#0FH
0170 F500        R     MOV     cin,A
0172 8003              SJMP    ?C0046
0174         ?C0045:
                                           ; SOURCE LINE # 362
0174 850000      R     MOV     cin,mess_lenght
0177         ?C0046:
                                           ; SOURCE LINE # 364
0177 E4                CLR     A
0178 F500        R     MOV     i,A
017A         ?C0047:
017A E500        R     MOV     A,i
017C C3                CLR     C
017D 9500        R     SUBB    A,mess_lenght
017F 5012              JNC     ?C0035
                                           ; SOURCE LINE # 365
                                           ; SOURCE LINE # 366
0181 120000      R     LCALL   L?0082
0184 FF                MOV     R7,A
0185 7400        R     MOV     A,#LOW usb_frame+01H
0187 2500        R     ADD     A,i
0189 F8                MOV     R0,A
018A C6                XCH     A,@R0
018B EF                MOV     A,R7
                                           ; SOURCE LINE # 367
018C 120000      R     LCALL   L?0087
                                           ; SOURCE LINE # 368
018F 0500        R     INC     i
0191 80E7              SJMP    ?C0047
                                           ; SOURCE LINE # 369
0193         ?C0035:
                                           ; SOURCE LINE # 372
0193 E500        R     MOV     A,cin
0195 4200        R     ORL     usb_frame,A
                                           ; SOURCE LINE # 375
0197 E4                CLR     A
0198 F500        R     MOV     i,A
019A         ?C0050:
                                           ; SOURCE LINE # 377
019A 7400        R     MOV     A,#LOW usb_frame
019C 2500        R     ADD     A,i
019E F8                MOV     R0,A
019F E6                MOV     A,@R0
01A0 FF                MOV     R7,A
01A1 E500        R     MOV     A,usb_buffer_index
01A3 FD                MOV     R5,A
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 50  

01A4 E500        R     MOV     A,i
01A6 2D                ADD     A,R5
01A7 FD                MOV     R5,A
01A8 E4                CLR     A
01A9 33                RLC     A
01AA FC                MOV     R4,A
01AB 7400        E     MOV     A,#LOW EP4FIFOBUF
01AD 2D                ADD     A,R5
01AE F582              MOV     DPL,A
01B0 7400        E     MOV     A,#HIGH EP4FIFOBUF
01B2 3C                ADDC    A,R4
01B3 F583              MOV     DPH,A
01B5 EF                MOV     A,R7
01B6 F0                MOVX    @DPTR,A
01B7 0500        R     INC     i
01B9 E500        R     MOV     A,i
01BB B404DC            CJNE    A,#04H,?C0050
01BE         ?C0051:
                                           ; SOURCE LINE # 379
01BE 7404              MOV     A,#04H
01C0 2500        R     ADD     A,usb_buffer_index
01C2 F500        R     MOV     usb_buffer_index,A
                                           ; SOURCE LINE # 381
01C4 120000      R     LCALL   Check_Usb
                                           ; SOURCE LINE # 384
01C7 E500        R     MOV     A,usb_buffer_index
01C9 C3                CLR     C
01CA 9440              SUBB    A,#040H
01CC 4019              JC      ?C0053
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 388
01CE E5AA              MOV     A,EP2468STAT
01D0 20E311            JB      ACC.3,?C0054
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 392
01D3 E4                CLR     A
01D4 900000      E     MOV     DPTR,#EP4BCH
01D7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 393
01D8 00                NOP     
01D9 00                NOP     
01DA 00                NOP     
                                           ; SOURCE LINE # 394
01DB 900000      E     MOV     DPTR,#EP4BCL
01DE E500        R     MOV     A,usb_buffer_index
01E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 395
01E1 00                NOP     
01E2 00                NOP     
01E3 00                NOP     
                                           ; SOURCE LINE # 396
01E4         ?C0054:
                                           ; SOURCE LINE # 397
01E4 E4                CLR     A
01E5 F500        R     MOV     usb_buffer_index,A
                                           ; SOURCE LINE # 398
01E7         ?C0053:
                                           ; SOURCE LINE # 401
01E7 E500        E     MOV     A,bootloader_state
01E9 6003              JZ      $ + 5H
01EB 020000      R     LJMP    ?C0024
01EE 300003      R     JNB     usb_out_in_sysex,$ + 6H
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 51  

01F1 020000      R     LJMP    ?C0024
01F4 120000      R     LCALL   L?0090
01F7 700A              JNZ     ?C0077
01F9 7400        E     MOV     A,#LOW Serial_In_From_Z8
01FB 6582              XRL     A,DPL
01FD 7004              JNZ     ?C0077
01FF 7400        E     MOV     A,#HIGH Serial_In_From_Z8
0201 6583              XRL     A,DPH
0203         ?C0077:
0203 6003              JZ      $ + 5H
0205 020000      R     LJMP    ?C0024
                                           ; SOURCE LINE # 406
0208 120000      R     LCALL   L?0082
020B 64FE              XRL     A,#0FEH
020D 6003              JZ      $ + 5H
020F 020000      R     LJMP    ?C0024
                                           ; SOURCE LINE # 407
0212 120000      R     LCALL   L?0088
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 414
0215 020000      R     LJMP    ?C0024
0218         ?C0025:
                                           ; SOURCE LINE # 417
0218 E500        R     MOV     A,usb_buffer_index
021A 6016              JZ      ?C0023
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 422
021C E5AA              MOV     A,EP2468STAT
021E 20E311            JB      ACC.3,?C0023
                                           ; SOURCE LINE # 423
                                           ; SOURCE LINE # 426
0221 E4                CLR     A
0222 900000      E     MOV     DPTR,#EP4BCH
0225 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 427
0226 00                NOP     
0227 00                NOP     
0228 00                NOP     
                                           ; SOURCE LINE # 428
0229 900000      E     MOV     DPTR,#EP4BCL
022C E500        R     MOV     A,usb_buffer_index
022E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 429
022F 00                NOP     
0230 00                NOP     
0231 00                NOP     
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
                                           ; SOURCE LINE # 432
0232         ?C0023:
0232 22                RET     
             ; FUNCTION _Create_Send_USB_Frame_From_MIDI_Buffer (END)

             ; FUNCTION Ep2out_Function (BEGIN)
                                           ; SOURCE LINE # 440
                                           ; SOURCE LINE # 441
                                           ; SOURCE LINE # 447
0000 200003      E     JB      usb_state_from_ez0_bit,$ + 6H
0003 020000      R     LJMP    ?C0075
                                           ; SOURCE LINE # 448
0006 200003      E     JB      z8_board_fully_updated_from_ez0_bit,$ + 6H
0009 020000      R     LJMP    ?C0075
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 52  

                                           ; SOURCE LINE # 449
000C E500        E     MOV     A,fw_bl_src
000E 6401              XRL     A,#01H
0010 7003              JNZ     $ + 5H
0012 020000      R     LJMP    ?C0075
                                           ; SOURCE LINE # 450
                                           ; SOURCE LINE # 454
0015 E5AA              MOV     A,EP2468STAT
0017 30E003            JNB     ACC.0,$ + 6H
001A 020000      R     LJMP    ?C0075
                                           ; SOURCE LINE # 455
                                           ; SOURCE LINE # 457
001D 900000      E     MOV     DPTR,#EP2BCH
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 900000      E     MOV     DPTR,#EP2BCL
0025 E0                MOVX    A,@DPTR
0026 7C00              MOV     R4,#00H
0028 2400              ADD     A,#00H
002A F500        R     MOV     n+01H,A
002C EC                MOV     A,R4
002D 3E                ADDC    A,R6
002E F500        R     MOV     n,A
                                           ; SOURCE LINE # 465
0030 E4                CLR     A
0031 F500        R     MOV     frame,A
0033         ?C0063:
0033 C3                CLR     C
0034 E500        R     MOV     A,frame
0036 9500        R     SUBB    A,n+01H
0038 E4                CLR     A
0039 9500        R     SUBB    A,n
003B 4003              JC      $ + 5H
003D 020000      R     LJMP    ?C0064
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 469
0040 120000      R     LCALL   L?0089
0043 540F              ANL     A,#0FH
0045 F500        R     MOV     cin,A
                                           ; SOURCE LINE # 472
0047 120000      R     LCALL   L?0089
004A C4                SWAP    A
004B 540F              ANL     A,#0FH
004D 706D              JNZ     ?C0065
                                           ; SOURCE LINE # 473
                                           ; SOURCE LINE # 475
004F E500        R     MOV     A,cin
0051 B40F1F            CJNE    A,#0FH,?C0067
                                           ; SOURCE LINE # 476
                                           ; SOURCE LINE # 478
0054 300065      E     JNB     realtime_source_ext_z_ez1_bit,?C0065
                                           ; SOURCE LINE # 479
                                           ; SOURCE LINE # 480
0057 C2AF              CLR     EA
                                           ; SOURCE LINE # 481
0059 7B00              MOV     R3,#00H
005B 7A00        E     MOV     R2,#HIGH MIDI_In_Realtime_From_Usb
005D 7900        E     MOV     R1,#LOW MIDI_In_Realtime_From_Usb
005F 7400        E     MOV     A,#LOW EP2FIFOBUF+01H
0061 2500        R     ADD     A,frame
0063 F582              MOV     DPL,A
0065 E4                CLR     A
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 53  

0066 3400        E     ADDC    A,#HIGH EP2FIFOBUF+01H
0068 F583              MOV     DPH,A
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C 120000      E     LCALL   _?Check_Realtime_MIDI_Data_Received
                                           ; SOURCE LINE # 482
006F D2AF              SETB    EA
                                           ; SOURCE LINE # 483
                                           ; SOURCE LINE # 484
0071 8049              SJMP    ?C0065
0073         ?C0067:
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 488
0073 E500        R     MOV     A,cin
0075 900000      R     MOV     DPTR,#usb_midi_bytes_to_send
0078 93                MOVC    A,@A+DPTR
0079 F500        R     MOV     nb_bytes,A
                                           ; SOURCE LINE # 494
007B E4                CLR     A
007C F500        R     MOV     index,A
007E         ?C0070:
007E E500        R     MOV     A,index
0080 C3                CLR     C
0081 9500        R     SUBB    A,nb_bytes
0083 5025              JNC     ?C0071
                                           ; SOURCE LINE # 495
                                           ; SOURCE LINE # 499
0085 C2AF              CLR     EA
                                           ; SOURCE LINE # 501
0087 7B01              MOV     R3,#01H
0089 7A00        E     MOV     R2,#HIGH MIDI_In_From_Usb
008B 7900        E     MOV     R1,#LOW MIDI_In_From_Usb
008D E500        R     MOV     A,index
008F 2500        R     ADD     A,frame
0091 FF                MOV     R7,A
0092 E4                CLR     A
0093 33                RLC     A
0094 FE                MOV     R6,A
0095 7400        E     MOV     A,#LOW EP2FIFOBUF+01H
0097 2F                ADD     A,R7
0098 F582              MOV     DPL,A
009A 7400        E     MOV     A,#HIGH EP2FIFOBUF+01H
009C 3E                ADDC    A,R6
009D F583              MOV     DPH,A
009F E0                MOVX    A,@DPTR
00A0 FF                MOV     R7,A
00A1 120000      E     LCALL   _?MIDI_In_Add_Buffer
                                           ; SOURCE LINE # 502
00A4 D2AF              SETB    EA
                                           ; SOURCE LINE # 504
00A6 0500        R     INC     index
00A8 80D4              SJMP    ?C0070
00AA         ?C0071:
                                           ; SOURCE LINE # 507
00AA E500        R     MOV     A,nb_bytes
00AC 600E              JZ      ?C0065
                                           ; SOURCE LINE # 508
00AE E500        R     MOV     A,cin
00B0 6404              XRL     A,#04H
00B2 6008              JZ      ?C0065
                                           ; SOURCE LINE # 510
00B4 900000      E     MOV     DPTR,#MIDI_In_From_Usb+03H
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 54  

00B7 E0                MOVX    A,@DPTR
00B8 900000      E     MOV     DPTR,#MIDI_In_From_Usb+01H
00BB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 512
                                           ; SOURCE LINE # 513
                                           ; SOURCE LINE # 517
00BC         ?C0065:
00BC 7404              MOV     A,#04H
00BE 2500        R     ADD     A,frame
00C0 F500        R     MOV     frame,A
00C2 020000      R     LJMP    ?C0063
00C5         ?C0064:
                                           ; SOURCE LINE # 521
00C5 900000      E     MOV     DPTR,#EP2BCL
00C8 7480              MOV     A,#080H
00CA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 529
00CB         ?C0075:
00CB 22                RET     
             ; FUNCTION Ep2out_Function (END)

C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 55  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


WAIT_SOF . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Check_If_Usb_Attached. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  must_change_usb_state. . . . . . . .  AUTO     DATA   BIT      0000H  1
  usb_monitor_input. . . . . . . . . .  AUTO     DATA   BIT      0001H  1
USBCS. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
_?MIDI_In_Add_Buffer . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
Midi_In_Struct . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  133
  start_index. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  end_index. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  merger_state . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  current_index. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  input_status . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  buffer . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0005H  128
_?Check_Realtime_MIDI_Data_Received. .  EXTERN   CODE   PROC     -----  -----
STRINGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
CTRL_REGS_7BITS_TO_Z8. . . . . . . . .  EXTERN   DATA   ARRAY    -----  1
LCD_MESSAGE_TO_Z8_INDEX. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Create_Send_Realtime_USB_Frame_From_M  PUBLIC   CODE   PROC     0000H  -----
  CN . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  realtime_data. . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
Rwuen. . . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
_Send_Single_Framed_byte_To_Z8 . . . .  EXTERN   CODE   PROC     -----  -----
IN_SYSEX . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uchar. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
EP2BCH . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DEVICEQUALDSCR . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  10
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  reserved0. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
TERMINATE_FW_UPGRADE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Z8_STATUS_0_NVM_INDEX. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Z8_STATUS_1_NVM_INDEX. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EP4BCH . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
GotSUD . . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
FW_BL_SRC_USB_IN . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EZUSB_Susp . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EP2BCL . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
EP4BCL . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
Midi_In_Realtime_Struct. . . . . . . .  TYPEDEF  -----  STRUCT   -----  11
  realtime . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  realtime_start_index . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  realtime_end_index . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
  input_status . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
usb_enumrated_from_ez0_bit . . . . . .  EXTERN   DATA   BIT      -----  1
WAIT_Z8_FW_DATA. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
z8_board_fully_updated_from_ez0_bit. .  EXTERN   DATA   BIT      -----  1
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 56  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


EP2468STAT . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
BOOTLOADER_OFF . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DSCR . . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
BOOL . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
usb_midi_bytes_to_send . . . . . . . .  PUBLIC   CODE   ARRAY    0000H  16
INT_TEMPO_INDEX. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FRAME_IS_MIDI_CTRL_ASSIGN. . . . . . .  E_CONST  -----  U_CHAR   -----  1
WAIT_EZ_FW_DATA. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CTRL_REG_0_7BITS_TO_EZ_INDEX . . . . .  E_CONST  -----  U_CHAR   -----  1
CTRL_REG_1_7BITS_TO_EZ_INDEX . . . . .  E_CONST  -----  U_CHAR   -----  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
LAST_CTRL_REG_7BITS_TO_EZ_INDEX. . . .  E_CONST  -----  U_CHAR   -----  1
fw_bl_src. . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
bootloader_state . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
FIFO_FULL. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
MIDI_In_From_Usb . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  133
CN0. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SERIAL . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CN1. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
SYSEX_RECEIVED . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FRAME_STATUS_BYTE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
NORMAL . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_?Get_MIDI_Msg_Size. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EP2FIFOBUF . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  1024
EP4FIFOBUF . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  1024
CTRL_REG_0_7B_FROM_EZ_INDEX. . . . . .  E_CONST  -----  U_CHAR   -----  1
FRAME_IS_FIRMWARE_OR_PURE_MIDI . . . .  E_CONST  -----  U_CHAR   -----  1
FW_BL_SRC_MIDI_IN. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CHANNEL_INDEX. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
MIDI_In_Realtime_From_Usb. . . . . . .  EXTERN   IDATA  STRUCT   -----  11
SetupCommand . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
FRAME_IS_LCD_CTRL_ASSIGN . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IOE. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
TD_Suspend . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EZUSB_Resume . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
DEVICEDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  18
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  vendor_id. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  product_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  version_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  mfg_str. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  prod_str . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  serialnum_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
Serial_In_From_Z8. . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  133
WAKEUPCS . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 57  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CONFIGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  config_len . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  interfaces . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  config_str . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  attrib . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  power. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
FW_BL_SRC_UNKNOWN. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GROUP_INDEX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FRAME_IS_COMMON_PARAM. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
USB. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Check_Usb. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TD_Resume. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Ep2out_Function. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  cin. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  frame. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  index. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  nb_bytes . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  n. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
realtime_source_ext_z_ez1_bit. . . . .  EXTERN   DATA   BIT      -----  1
WAIT_FOR_CORRECT_DATA. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
WAIT_EOF . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EPIOC. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  cntrl. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bytes. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
I2CPCKT. . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  count. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
INTRFCDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  alt_setting. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  ep_cnt . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  class. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  interface_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
SEND_IDENTITY_SYSEX. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Create_Send_USB_Frame_From_MIDI_Buffer PUBLIC   CODE   PROC     0000H  -----
  CN . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  midi_struct. . . . . . . . . . . . .  AUTO     DATA   PTR      0001H  3
  end_index_local. . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
  cin. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0005H  1
  start_index_local. . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  end_sysex_index. . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  mess_lenght. . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0008H  1
  usb_frame. . . . . . . . . . . . . .  AUTO     DATA   ARRAY    0009H  4
  status . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   000DH  1
  usb_out_in_sysex . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  usb_buffer_index . . . . . . . . . .  AUTO     DATA   U_CHAR   000EH  1
usb_state_from_ez0_bit . . . . . . . .  EXTERN   DATA   BIT      -----  1
C51 COMPILER V8.02   USB                                                                   02/19/2007 12:06:37 PAGE 58  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ENDPNTDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ep_type. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  mp_L . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  mp_H . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  interval . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
Sleep. . . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    990    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
